<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DataVisualization</title>
    <url>/2021/05/27/DataVisualization/</url>
    <content><![CDATA[<h2 id="常见可视化模型"><a href="#常见可视化模型" class="headerlink" title="常见可视化模型"></a>常见可视化模型</h2><h3 id="条形图（Bar-Chart）"><a href="#条形图（Bar-Chart）" class="headerlink" title="条形图（Bar Chart）"></a>条形图（Bar Chart）</h3><h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><h3 id="可视化作品"><a href="#可视化作品" class="headerlink" title="可视化作品"></a>可视化作品</h3><p><a href="https://www.gapminder.org/">https://www.gapminder.org/</a></p>
<p>多个维度展示整个世界。世界人民生活质量、收入、人口，不同国家和地区，不同年份的变化。</p>
]]></content>
  </entry>
  <entry>
    <title>Mi-Hang</title>
    <url>/2021/05/02/Mi-Hang/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4278264620974d8f979a76a5cbcefdbc15fc8a9b46eda249f1f93b9c4445eb25">d8e387452563cafff6ff80e7fac7f02d4a15e898e48f038908f831f48417c7992312d33cb1ed69312b5e9bab8a5b4fee02109ae64299b02c284c37f53a4c45656ab3de228be6892179a77eda43abe4f639d4bf979e02d85f4851564825c1831973a6fa9e8653f532e4cb83d47f18114c7d662ef75271f632f1c50b4ee2b8e711cfd8bba53be997d70d1b687ada04500f5eb4b97cc942ff38164de728090bb3195770cb2e557dc383e345d225deb8fe83880efe517ef7db473f76a7fe7a8e6eb65dba08a38db03d25d6e1f5f86cbc2d00a6cf384ef4f4b66fb5961b90cc3ddb94b2423eecc99ec4b5d9d8ac1de8ba771f8a2a497ee946ce07b63969d97ff839c138a243ee68bbe71873f6be9721022a2a9d40b2108816b22f46c6b5f9029ea100737cd1623d73e1a3c385ab2792db43dbc950310386988a0c33337bd4f9da3c38eb56d19abf2da7b8d88c4bcc9d0c00b04386a07b1d2e7675d3dcc5205a557f6147f1a9abddd8eb08c4895c0ddfbe6afc776d93e914d1bb2309064018c6549e53672b858dd0afd18ebc9b0b9019d9de42e7727155629664098a0617281fdb1ffa0c0f0447c0618eef727b285742c58b68a6d8df9d3a710392be1543099af7bddff861f83992588c923c9fba9f4b1b227d87ecafb564d4a7de9d1ace1c5988008e28f360b8c6442720d2d47b5b7340bd6377c27f68721f6bb05f31eb21dda74acd2a0f340bfe9351edfb43a3253bd681edbbe21d23e1ef1b86c85a1d7e68fa8d965c04270145f7136efaa411396d0edaab6321604d92db7b3c9fd1a41f4b1494e7a89f89d1d0a7ae2ec531d3955a793f92b18b97daa76282e1a0bc23b0cb9ae5b410f32d3f9cee6a03f2f5d9e97ea480b871ef5de54f8545b09c8aace4a5c1ee9c19bc5746e86d65a9e974e422e4b52c50c49f3caa851a217fe73d694a6f872e43f2309ecbbf4f06fea8983f69289c3d94d9c21ebb0dcf14b02ccd5422b71d7027e7495c4d3507e19142c73df739b805943cf63052fc77b2b91a990e15e31a819420ba39243b2ed1f17fe7afa3f0a54b3a8aacdf824eaccdba389ddcaca029839ad92997a7ddfaa10dcbb3c0aa35dbd426117be71575794fe342f6b89350f5f1659221be9f086671e0c0ba09d5fbb53f7ea5872cc1b19427ae25a46b4294242ba36e93b393c5c30812f8cab8518406c079f24eebd5b07c557d29b9c4907febbf2504b3059df44c322f1ba6253cb5e2c529cc088bcde9f68e4c28c223112bec8fd8b53b7800c6b166a582446f722bb2f7ecfb25171ece5661ab08c593bda2a154d58b0216e275b57ea822c8bbe10ec6b84f395da616e3a5ba529d46cfd6f88632ca907ff6c4405cec4071459792a0cb4ca813a5f72a2e80f9f21bfd93c76e5ddaa070cb989f11ce8398041db5bd11ae41d2fef3d69bed89c90c35fd77e1f868b3e9c32fd39b02e70f34da95ac26a9fb496ae989ca5443b158b3a11f0149adb72f767b22837e7282573ca5dd0702861f83d05c6a2ba1a73d5a66e16d5dd73137e5d38298a12cfa6478ecb77aecaf24c8169cb2ab19dc57a22bb12ba05f74ff620094bfb26060e6d8cdb345a64f6c049002863b32a50a71aae8fe5298338b14e8a070d0421242fb7803cc5bab7eedb4de2799b6b8e48a88748423dc433c9cc927cc7781613dc0cfd6d9b0f362508dd984bf0db535694d7d239f6bdaac121790220cac5f3da6105a256ffdc3f4cece1761aad9adc7e6ba76350f191dcd53472b981738b6d098e21ee3bcc68e8c7e06176c9bf6854151b8bb4bff34016360fb08275144a99558aff955c1a7a58d5ff3af13041d83e42271f98dbddf1dc786cc9a697ff9dac1e814e582965d63b596c753f287ce4c34ba0f6781545fc1ef342b4a96cb7a799a6a5156f732671c47f2f13075a4edb3053627b82cce32f97267004096687597c08380a45551ed68043482eac1d25846cd0ef5c04f0193da7cd07ddef594e77533b85d668741e34a39c2555c5cf382ca043acf7a84c38ac91900a72dec5f0d686f16fe3c51130dde7ae8f50c883bbf409de00936734c0d3b3688dc6bf3d03194a72b325350a507aeb94c68e830e095e97dc1c0d8e03c5a9ab95f7ea75af8f3024691d586682b7a5206eb77a4ef8d9d99dab8ea2bf739ac9be54871e0492e7ccaf2841bac11b0543242a270823391dbb66e8e6d50ba0ce9c7806ae0d944bdf478e3f51a7b487b9e21e3559f98b0f9fcab6d2bd08a530829c228c3c0e4de8c664b53090717a78812546aadb3cf8d0a04ff462e0dd44ddfd9897a4e92c7f940fb7e41855ee5e2e3cc20929dab0ac3df2329ea1ae7647e74cbee5c12d5d91022959c2aa813544ceaf9804bdc5f9930c4aa13af41d0fe2964102cf12c232f336c0ef957072402bd87c228cdec84e701f7c44efa6d9938974c02d0f2e626f2d800acf5af220b6a1d3bcb9390ef3e30c842211648c9387e8edeea5157d70b40a1ad540a9956a3568519495e43dcdf7cabf663b99982048f684afb5668a135815720baf318210313a50c895c8efaea557ac5db1e78a0bbd9038356c69e8961bafce57b57706ef304cbebca55f361c98efbd59511e939ec9afcb475a9ade4f955e48e1283be014a6103508f7871ae58fb926e09520c8a86ed59c139034aba6bd505a0cf0f876ce60b8ad380603dfe99467ad8c71a6fdc4c02f8def7c52d07b3c837326a59b965e2f5bc73e323c8bb7e0a9d1603f2f0c1ec81318b4712403d48b8a5993758e0330b737e0154f78a19a13141f04ea72a1679269350ce3e46386c1b892ce2f7f61a89ed9dbfcec1e7bcf2892c2a183e003a53d34f38743d28a1543afbd3360a01695a8a91a8fe02c748c844a7f73472cc92d6dd95fbc9b0cfee57c7b65014f0740cfa036fc6215e4ae045ae8ee5c1b7f2ef2be2db93ab4b19e8860ce5a56e70b20bb51c230cb0475f18637055dc0bbaddfc059656d3294c545274e80f9d0a6bc618655a7c504465ffc41878cfd2dcfde5029c197ee9857743252d9a06708265ed58a247bc9bf976ecbfca55652079bd58cd5a12adb68251e5fec7d98aa0fa3ce265f30f9d95aee3f209463b775fa00728acd3bca5cc2b1d73259b9c7ba556c8faf048b48416812342ad43fcea37555f2b0b4fc222ab58af8fba13598be41c4e08240c704c2fe588ccaf63236eef0f95b7fcc8b0c867df1cb2dfd25041d769aa6a30930539f0b59f64882b287901c81834cea1b9554bdcf9a14d8f298d798e8586aaf19fc35f062e2cdfaf91fc1ecbb4c1050a3154ac91bdab85b2bd2d7d155c2ab90e1c0f60b25edcae7d17f8d11f4e2a8fd188ee2900765843be30b350d35039a24fdde8cc45e3370f6d965f05e45daeba69db6a81b4b2080d3ad408cc2782405ea8091a2f403641fe6a7911c0f8424e1432201dbbe45dc7d35f53315580fc9e7eeaa62928fd13709a4a3fc55a50f9b66fad3413e8818392206dcad791ab5d521d0b668f3d813d99ff600ab0194ed78bdbc6c7214a87995148f78347faf24de8934de52ad3d2321a1a448dbfea47d51fca1963545472a396035fd00921d73f01882193aec0b8f85bae7498f2a470e150c0aac5ac150b9770001ba331550810069a2bf9b5f25c30bed0ca8c4e4a086d55d085c6f9f6a4dcb5de9f4f41ed78a817b2098ea9d7e0eea1741f18d4066e567dc25f99a03263ef8aed3e235814943fe849a49e066d72dd1eb29d2c59b7178656c5c587ac61a799ed50bdc8d60779cbe58c614930a8d8be3d75413ba35adcb01c6aa1d6a9902e43c77b5b22a7cd911b277e9255ca84df8a5094d4638a0d2086b15b4cf9b1011d9dc2762b25ae68c75e575048db040a469dad33d6aff82cbd0b4a827fa901846377c2c47469e6e768212907041567a604f8f47029a8dec5d05ebb2f2b7a265e272c02ec87a644fd1b5b149e7a594affce23ac7c7ede62f3dccd29e508f89d726b56532923ae70792edd732c4a70dd8d87ac46bb1ac7dce78dee36738df832041b736d38754a4f53336708199f79a96bd2879c4ad6bfe1e438ef04164c14f1b17ec06352eac9ee09e79be31c4cfce76cd5a044a82baf4508dd2d125aeee9a85fae0815c10653485d82a9da24437646afe83da42d880fa83ac29117d40ed1fe908bcbcc67d18bb89339f5cfa43298314081027f0f089654cdf401cf744efde35ab761526e3bc8a9f1059a681952fe03cff3ccfe1a10645f7ed1825f3c224e3761804b2ac93a47e0b64084edfe333de0db2fcd9d85fa817ff8acdd9621f8493f9ca99fa631b5166c0ef25084395056daa9acd6d0809bad10c215a4ea7bb84ba9b3cd755d43188074721bfc04038e56f728fd2cba34bc9312417ebb3fde5fa7d888b57d259d9e2d7587323f277a8932cd37e0b532b143adc5193a216e667a55a07228efc9e923878c4db506a8fa5b3ebcf19dd59c38b37ba796dad2976e9d7e3b9ea98356f805cb32a95373f6f3193e3c6050c492e030c1e15537473b985ef950fb03cf0eb7705b6a40a2078d33e6f7b839322d241049e4a73680ff104087902adab3da64b244da850431051cf33d21d62d434424675639b47acf30b85a24ddd57bda7d6b60f5a7714754353099c803ebb931c1a17aa32f45093dfb8d80c82edc7885c6f94c7c9346d9063c3db5c6adfcf1b28cad6a1972913735abd978ab4825d268302d8f300cea66f630ef415daff213872759c88ad2b34d1559e246b23fa166c0402c0d167ea3c34f040155f81ae84bb2fa2d1929b571f27fc0ac1b4ce5850e42c10f5dfbb8c34c8a53536dd7b9c85dc49981bfa0abaa7a8d780b0ef228d31b53ea88275517fe24000fd5b78e528e28b2a945be3aea78759f920a0d0d8259e510d61c0b2cedf5d4ea27df468513206bfaacc2be4cb3296ceee717294b650880793f4c63f3e50afaaabff7faacbf675a6568923dbba851797c7ba8d0637f4a7c6226afbb9eebd49b010e6dcbe3d6119931309008216090bf033cb5743cc4b83a353e3a922dc1c17f025b4abaf73c33eadf7693fff7a1e8832041b9f84e4d25b86fec7540bb2672f6098c4cd0f7c72ec1a982b08127c0afff1b9f049141111e2388481985fdc8ff798805d07a884989271bc69f163e6fcfaeac34bb494a9044d0fd8bc610b357452c4589b98918b2f3c9ff96ab3ed55ec27fc18a9f49e4a1865fa0f0372887083f9915ffc6d94f6b6259d91f7eb4111bacb5c65ebb5a86c93d1d36856b163dc5e2b854d84dc1947968a239de1e8b22628eb5195187e23ed21f75aedb6965f591f9acda5563c82cf6890c9390f24b73969fa87fc3feec5186131923a21200031f5922a05af264a815236c30159025a56a4c79f2fdbff404c34ab63fc3184038b8df3a13a79f11f6ebd176c8067444afd454d0ec495deb3239777b2707eac48df8adc8e07a08e6adc74fe01f4a43d91fdbd9102394a2caefed8dfcb0b49e94649e748b6065800417afc12432a13e24986013d1c5329c23a9a31686d14c036de9bec0b49eaeab5016ad2d53f921525a14d34d2edc80837d7ad255784cfee235661bbb5f91996bf2806b9fb7feaac6b4a70b0c667c773352c17befe0343263fb63df45d614716f7a97e9c013ccdc54a8807e52fb0c0dd0f11382d865bbf523b7bc305678f4c592e7191e35353a6441de8e1a4a2480f01dd3dc6b56b882a6c683c4d1cfe9b3091d5f6b24023d959c9bbc63d32969a7eb9e0cf0fedad44946c5732b7399075e7c66dd2c72a7ad1ba82511a7332bb796da9e6229305d599da39f3597bffe2d65e5971cc71092d077e2c1d4d06938587f820f68ff2c51ef0a1bd701fdad32ad33e0c130d2bb360d2e4efdee3e7100ff3deada0383b55353e2f3de22a204c73f9a9eb7c77dd611fe99b0cf618ebd645daaa8401fc89bcfb4544b23d24f3f4d9a7686ed053b668d425c59c20426b78c9c72bb8e97d4e74773a4f33e2387687e0be2f157e180612e33b492156010d846de62a8d6e6e6a636b0ad35d0e8411c384318442c532712e35f72113e740c59a209a233f9ea186d65d752341c344786a0bb05773b78a691492fb49c9a014eef8f463c69c59d4cf8d1ecc0ddf094fabc315a8c558ff8cf11c85b38f1577cc1451e90a48ac6ec9145fa44e83b5d322956af1a618fabe956ae294919c433c5fdce4a8cac734d6ac25d63ffe62b9215e7490ec46f07685b06f4595a128b9cfbb3a970513eddd5aa08e0f2016e0813bf487b33d7b13f118b993743c7fd3dc5d462deb87ed4978b7c3bdb80989b2acf9ef34343b1ab3460d4420374b50c4f6db974992a3253610d1daea48d9a7f44b2052d4ac145d85822fe5773c1d7ad3411db58124481580f0d6f54ce1db19d10cf8ffa5f2c7ac516455e649d10ebc209b2cc17dcd9263cc4f7c515cbb6d715456a16d25eea5365d9f9356b572238aafcad9e4f6537faf8da4b8788cae35503448344768d0495850db5ebee3b250fa8aad611a86eaf6dda16f6484154c078383cb3f960c73bb1dd9e58102bac051d01af370c64d7e5b30d61d17339e38dc84b624acd6fa7fc4d98d284fd87667b0595042bfb2b16468e4d3c51e40c34046ea2443be4fab7cbff0cb1791d2485eaad07ef452d7315e3e25a734755cd82df4ca6d5a90875adf01c8a5134afcf01045dcb5e9ecdce1e9660c628bc731ee5bafeb48fe27ad441c901854f22737e0f88c7747a3be29165864c8084ea46e7943894dc30dadb6da303b911892b163fc3c3c6ccb70f85504cf4bbb0a78eedcaddf4076dd2686575658c1c8c4185ea172d8c91154a0b44049f0579c9977227ebb8df15d1d46c5e6c1cb8b78dd95d7b83c3da41675a5a2968361baefc40a894da17864337286f7678bfa2ca6fafc5a4895c0bea46026a3c1d2559888c6555893e43335a3dfbe080a2f2c407f2e3dd3c33d373b5141ebde4371b5f9abaf5d416c3dc6dddcc4f9532d9885ee01a42905a0078dc3525858e9846eb1e92a03d5f355a782082326e56074323e9e60c814b956f240fbbfbbb00778b63f4169064c8342872bfade6524ecd619671b696c0b8f3b9e44ad4e53817240490b3ff54000d75fc0e86fc8cebbbd8edbe8e1a395c0e91ee950fe6ae84682d8b55d4f6173ac982f27fc79ed3b480d2a3254e7c0676389272654a52ccf76cb49cb91f06a8e75c3205ff31372e9acbf4780ba0e1264de64837b0f27c20b238fe7517116deaf7df0c79c36747b95a85503013cba3c2f448cbaf1b29b44b709b08fd6c3d84884fdc1e86d536b8ce35d7ee27685e42642cbd42afec2804711fe2b6f58fb7eeba126caecdb8e1f59c82e6c6735eb875136a4fe1048c171896bdf8990319f931afa4c62be92fd93eba2f15ce671305bb87e973510d450be7cb5bd4f9f97db88a866f1a6af7db87a02f4b0da5f96dbe1aba94d7bbd28ce34e8f97501857ef7979819b9ee663bf4721f7f8b90e1891a0378106890f46323b7cbf51929a86033f5949a3a39f4b7b0ba3767bc756b5ad35f0fe1803c5b22fa355d27dfbb7be48e20d11499a29f6a1e2fddb268ac1de70ebf1e93c9e56ac318f29819605071881d4946a0c9d8bf74e45d5f6fa390f4adf017b7cb1266b3c345335da789082b17193d3bb4706aed487ea38261474bf273f55db7ba6170ac21048df22cd5776f5d1196ddc891d6e6451ecf41ac39e27d55ea095093dd1e34e7cefa23223f71a59cb066a6828b495c39afddc2a71e8390ef4f46a5c1279a8e1ac94b91663a722dbddd229f72670a70e65c830acbc779f36d75a161519d189bd646961f9fc39dd0bb71e9fe8db46fa2d71af090caa65db597d233aa337ab5fd1b30f58e25dba0e1d503b1eb0e7e5f485d4887bbf99c0d33ecf07dc4de4ee6dcdee5898e4c9e254db4c94930751c83fbe3ef6316f27ff1b3684f78a97e3a6dc6c2384773cab087c1d539f0ad246ad79a5e699f71ff62fcc9192dc75f170ae09b29544729afa0773ca017cb9a5429d13b3cd39e62ff0e9ed3173e5a70842ed24a0e9f60dcfdc97c447d31682fb2fe8ecdc6edb2fa62cd4d55e38d8e493eb6bf7f33306070f1b65016f5f2b5dd7e7fcc42b4841cb3226f70fdfb9164bee5a83f8e7e10a1a55c6596130917a92194d7130a5275583985d0a9a0e6ca02e4c73567c9ed8f6ff6d5c6f59511672430af3c5f9e6a436b93607ee9c0962ef6f36bcb3e3ce66ac944f45d4985409b1c475a2977904be26908134983e92ba373d8ef9660aaf38035e564fd4b586d27ab3db8623c4196224276360c25faf079af81cf059b0671fd29c655fb32bd6b6959d6d1a32d7043ffa992f7491eb80f48bc177ca9ffccadce58ae0e84e05cc978fe2122528a075337f271b9afd676cf590ddb668a6de70132e671aabc481d99c20553d5135926340855452a17c11a13465fbd595935b95a7319fa1f38f81247d22e20182fc81b3ba345e6f34a68ff748ed3645781e2bce1638d7b5bde78e1b88b442927bc51578e4ae36eac38088e74d33d3685389ac7cd4df4ef0b73aef3c1bc183e62db837a36c5e677bede1b40cf89b7a06a39c7e8e13656df37a6b6bcbc07de5b1e54ccb22efe2d170983589d5c3dc14312966cbfce324e298d188d5ab99ab23eec8a974d0733af57ca988fb0e1a378372e9ed6ad9726e2a7a41aa7fc167f41c0e3cf91acb67c89073d433eb6ce949254c30418e63399744e8f0dbbc30e465857a89b6fd7f1365364bb37f986ce00050ac37641344faa249246997a7ab9319b3d6cb0a3197c027cf539581e85d11ca9ba208ac5ffe372ba39afca02958a3a4db7d80cd40f8580c6e352f20af3226885a5b265b5243ffbfc8362268fff2ba4c911926405fa2b70902c3cfb6ebae3cb583190c4a1e4ab1f99ee4dab4c123fe6bb8feb5133b9162e956bd5ba4e270a021ef61b63cffe763563f4e71f7b7f1423b61efc65845e3c21917035568abba35625f29d476ede19e0007393f40691b3f1d05338789b9818454bbffcdb3936bd95d1aa4</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>Xing-Hui</title>
    <url>/2021/07/03/Xing-Hui/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="5462a7f6faa465b407ef7bc84fcf2524e3d213a1a65a629c1e601fea258e343e">dc8b967f63c3d0738c207bbf5b3668ff20a2268ce2b4c3e2cf181a545f5bd2249f700b61e268eb4ca1b022d6d9706832f5a8ee59892c8ae7355dac36677321dec37f83557080158f2d1bfcf704eddf6695716209ead3fd69de28724383bd1450ca41186616f2279fcb0cc0914c6dc47debd7061251d5ec0020cffae7eb7f1c95e58c0836447f4605590a3f46312ecf17885dd504353c67ba4ca29447a692bd4e7174c503f4bb60e3c16c30407643aeef9a35abd62711dd594b002c96e12a609a6f76dc70ed870b3df4c28084e3d70d956c468f9334459eaa34eea1b5108968c3f6cea2971c0ea51d8660bc58a7333b27f9accd0aac6865d63850ba1ce220177513908233d1834f1782a3126ecae6c442dc15a63db06f5942dc85bdccd6a705269da245f54c288a2020e56a849ecca82e77d9afe59b77261502fdaa2d38b4fe85db2648fcddec877117776e49a4ed3c57273b0ac56eafbbea62fb82a2510962e1abd8024953c96284916dfe48900d1371aedaa36471ccad36dde276da6e44edfbd5909b58012cb8cef6f6bac924d7b136085e547da17644821dd81ccfa80c832795dea640a139ad5bdd73a743c239b8dfdef8e56f8891dc7ab207ccda9988c268525cad722a6e640e33c78bc69a9130fcabfee957af3b2df7677f56713544f3b9a4f2a36e89fe6eefa0f5204a24258964c8032600416e1aef883a4eab1d6debafef25201b57f0b8618a4a06cab7079be993fd88adeac7409103867dea079047ffac5b2b782146f4a301ab754a2a1b35a43187e8435ebebeb4e227199c66c10d2ebfe7858e54934d1e51293652552b88c6ede37ad1b44b1651a1504835ec3df4acd52b90c8cbede6ca209e30ca6541cf17c094a676a51933ea6965aca61758c38e86ef96a23b1522f79142f9c1d871a5cbd3f0abd934fa7c5c780ff8df091fb3e30d95ca3b3c70ade3dcc6589a969d712cce5238ac5cca04073c8267961919ba01ec80e841fe1c06fa319b02fa99ace87b505f310439e23a6aa4baf37fe7c8b2ceb9d2f8cdbae37f8a206f20712b71833a31717de8647f9e041f4627db757eeee0d17904032cd9c1d0eceb58fe59fe7b48d5a6b5bae54d58abc5dabd95d5bef809a2468bc7aabdecc6eeb214c6c5bf1017e619c32d0845b2f3370630725c8d19cf7286b39356d427038286290d545cc1f06845a8978bd4204be223daef581bc1d11d89fc050437c9cef470764e1f53d39ea8727eec69c4134b5d26e5ca52664bee2765a4ea18f1d6c60bb3c521be8cdc77941eb10a1c91f15178f3be8e4313dcfa34a0a81c64ceb00477fd14d1adebf4f268fce3b7d920a7ca9d51b4b51d73023c45d8c21975c03da063e4cf1d3187ea0474d7e3077aa76fecde53cd7b5811683ed095d97f875af5fa21f2a5bc6d67244cb27a8f7fbcd2132d7f20466b5c196bd81e519bd5d83636ec982a98803aedd794672bbaf7c88da3fcc53dcd6d7f54b369273f35e33b91b4deaf4b406eb425c60ae2a0cd50b834c994d27e230c816c3b979bee3ae009257a4f4bf9b09c2acc4172b0115e2936cc421dd29cc0e2edf111d770dfec1c5b245eefa2be1bf2e6b43fc60e2af7372732e00d0f841b78b629b090067574460c5b591d827ce0037de39671d94d1a5f036559de3cb25a536536cadf7466b307ba386688130615eaa8c15012dd001c73cd78c6582f457f9326d898f70c23d87d735de72e50c00220adfb25bd1b43a74f137d2beeb810c4bb0e9b09a19a0621ceed96f2718e6f2f711d2684151d6111fe6b58d3f511a33c71081d2683bfe94662d4b18a57d15c274727253a065c276f948b4c41e5647f5716ecaec27b8f0e2e8725bead70864bbd6c4078d3587819388cdd135a98ecfadd14c93756bc09b5f551915c3de44dca7ab697ad1574b3966f9484b70d314066c093ef92f892dcbb86a9c35e51f92f101242cf3b8bb8c360ef1989f0fa19a016433a47d877b6f599641440a48e645d5aaabfbd742943174854a019798684762b538493cfc4e1560a4e39acd5d2dd83521f603370e0c8da2d75aaff15a3f0e7038688697f48416c39ccd81052755e85d56e620f5528779e907a63b1e48185821dbbd9658cbd7f8e8999ca74195b50397119838c614c99f9f21f96b37755835d13ee1633b75a456ed1934271875b9e276b807997e9e4bd179224743e6810807707fff718eed3e7cdb76496859ecf9ce7f4c9e0d714cc243b033e9b4c648be74e1671341f046612df87dec7b275b4c42e17cbf1cdfc1b4a794710e8a795ee45699034933687c3a4d803304b664457f0e615fc9556323e9a91659829ba38d0074fce7f21f0689ce5382a8fdee871db9e6081854c678a6f38c1a70837adeba08e905423d0e08b30503afbe7574a6d97d6d8eb1a3236873dc3a125a865ec6a7b6802837ac02eecee16771ec5ba472078a6bbf404460c656d2b7f10aef3031a1c3a1ba60c44c3bcc5a0b57ab36406231d6c2cef3b17cad0e251f05c7230fd669ff94d6bef38b12b45b7ba396f4bd2c5f8bfdddcce06b97c223b0e6ebb61afd3b17556eda56e93c04f15715b6ecec1e57b60782dec8dd124599d6bf2601193361e6c73ac9fcd74a83ff9ad5faac5f3179f2a931b47efdb838a0d12d5c0afc79239ebdf7b27ba8e7a6912ce2a510abdd3dc41262e70370f7b39c6310b17ca7595112a837558548aff19cbc9049abd605a016ecd25a8e06a02df328dcba56c9b1d6ef0c3b22e5fb71ba0f42411adedac43ca62b11d554258d8ff4bea50d82db45640d1c166f231e42120e242fd241aa6df6946c1a74f0d3f12d9a44d1b7dc8afe72a97934da67f34d3b3e489d6ed90aa246beba0695ed91c4c91f973c09ad8be223b9e03b470ace7b44a9b73eccbd38a95289b3668786acba34a20b4d21d2bac78a4c85bd9ca65f0e7d4a923671dffeb42230b31428463aa00c3ba6005f5fa939342c1b86b619009af2228e405f1237c2a5413858f8625d58a9eaafb51d7bf1eca4fa4007d33b2858b968bdea77ccbeaf9909a8792edd05a5267d4ea9cd27be9d84eb682e4fc648897c9cca4bd29da9e2e7dd78b21f14bdb4b0fffa93e8d8bf64aa13ebe33e69ba05afb750ce97f6956fadef8c8e417ce3d1b8406e435d019e40058923ef892f767bd193b137214ddebf3288036322d5a877015851e19c6e9f584eea316599b217100d7ade37343dbef7e4ee5d311cc09f4ab66efafc971df58840211e84c080923563e9104abd297ec89b7d2c74da5e7df9aa633a2071e4570275ccdd130e8c831ca0de5374290287c093174d2db010aaa558d7cc93bc9915595709ab5f6dd59d6e421ae7f94b2b26232e55a74b94b42a95061b72e311ed02cda60b66a7a4b36b3b2f82cabe6e51d8e9f8e3808e98cab29be6c17d50f4b746928e2233c99086f3bf34215c9c783f9a13883811c96f2fbd1cd2a6c2afb1be4b7cb8266a9d3b3c76032495e5bcde233c7de5987b1c9830a783d324f565360ee5e8a25ca96e5294415ab819a1d0a7302c385c74fc171b6596592dbf0dd5ddc44558626e7d4601382e3e0fd01b8ef26c5f1f8e4ee7c3ec136a7d91849479eaf51303d9b24a66f55261c0a8fa448f3a43dec904ee8f480f52958cfa7e79f31cec85dc688e8b0bc408329ba3a38e053874ad34f833e8b4b4a7aed45891dbbac8764c6dc1fec3e5b914f136dc9b17b60314b8987371d3f617df7cc8f0a67f803a858a0e086126ed61272daf6b305a2c627741ba06576d1c144ad98e4a7b2f92cffee36e236df1d1a8db72676fb7259ad33ac06c660dbbd7fd49659668a8381a209f557c9123a50250d099f9381457a876314d510c68a1195aeed1fdfe525eaed9be2025559320f1da3458aef75c113cd22db60e07c6374bec99cbe03a09f7269a05a3be1ea25f3d1f6723f8452714ef40d42cb12e6901902089d7aab4ba4ccc1a8d8a90d68fb2556ade31d0ad8ef2d2a11525d2d4edac00b5ff436259efbc4f90272b18fb6ca30ab3dd76cc23e59f414b9e09e988c6247719a31f5f5ec5b993e27e2cd5f709485f067624432738f6159b7961054209c11fc95f72f0e47e40628ffb3f28d2eb164ff5acf32c9351850035786f41e3b84516214568c5c67cc1099e67f9f4330478aea2b85eb4e22e5ed2a28ed6e52f40922c9dd7672253c0bef74cffc969d9e807272a9d128184d59b67aea503ba5e7b83475bc2eecc11d606a13be7194669939437c2e42b47aad7c23f49076ea412d10c3e1d3b90c96cead70b91ba8d69ae4f395b9a09e3dab0f3ca6b15073f0e05ffa7b1991f3e0f7df10a0a6e06f1eaa3b1c2de04a83b2f07e4093ed4632157973ccee6c3879a43d3d325f6a73017762c32f18f4907d1901ad799cebf9000109e45199401c05c3ecdb1fe526e1b531f5eb435d9ccdd93b93ecc98b5293592920843b822e27a04b980bc7dff9c9b9a70b6bd208d9812011bdb8ba3115916548a7723a199b3e5ad658029ca15174f398987ef44b845e35f0e7d74de8fb03d1eb5afc7a875d9a8ec89b267a30f5c64b95648ea06ea8f0175745a9450dda5392d9474060190e78ecbeaebd5c8dfaa45a9a8e6a06c5f9746179fecef2c73fd87b786c53688fce75cfc87759b6cccae3e330a701f7cd5a04f79542ac3fde65bfdee04d7aa2b7a6c1193141357d6a08767f9d6efdf33680e031f289836b2c4724ae12011de364fc1021943b74c4686b31b7a16b0ffb429954d50184d05866b8c4c25dada6135a05d9a22baf05a71470d076ac260bac2bd7f6ca0f477c317b874638d2c0443fad2d8531d3c1ac92b0dd777f416614b50d5ec502934b247f5b6d6f5bfb99d7193ffad9684511162166f1486427ed782f101f46a23930818db1f0b86d80352a6ef73650b0432b2a3e00b715e730f396b61ab55d429966c551b3d304616b3e070b3cbe04482bb9d4e9ab784abcd9f6b3596f988a5415ccc61c1fe70f76c0b4f0b3024ac0ca73815223bc94dd5c3fbcfeea7f786abdbdcadaf38ded688a3914f078e4010993625f07e624138c5e643d30c28c381d43b4c35046c8ce2e22a6397e53e55ccee67ba3bf9e5e4afcb58c6a0738290b32af08c74707eca8ea080eb7690797f9c3fb68c7e29e24c8b7e6db1c395dd91bf1404f4b11323f383bf3473d36b9ce24b4552198d35e33f8decf3b2e80d4a7c7aa91639cb95c8655d69f548be71c47f2ffd7ded1db3158fc563502a20665ff53d161eff8fa6a5bcc3df6424c50a392126b5e52c1ea702b2d327886c2e1b4b4be2e821d97c2792023cd576657b382b627e96dc8b36ef06b628d590c26f83d374f7a8fa920bb1009b8ab27c926473b61b3143390a1262f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>secret</title>
    <url>/2021/07/10/secret/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1e36e3295916348a582113e0c7fb06bf329db13517b0515ee4aea7fae8575fa8">8ec44e4301c2898d801fabfd4ba66a3e828d9490b898100360eb353649c449114c19e0927a56f2b7beda0bd41a97b1fdf59f31d508a843c4daabb85d94b0b83684bef806961d02d03991a0db471ae924b2afb175d911d152873a43d133b2ee045932faef8189027c414a4d2b3d6452fbb5b6ff94e436b61f77657f77e35a51f6a14ad03e455086e18aadcf01e49e787428c753f0dda36296398e6683a22c44d19d25ee35cf0df8e1bb6ebb2316fc8fd23d9be1f3661c14757252156369d93bd533a2abbad27f9f1429169454728f562fe43f88035e505fee920188d2fa7f9d5f3242a65fff5b6927efe3dc0e83571e3dcebb4cec7b46a221e38d7cfaad78c75e2df897a65b7ff6838a9f7b3dc8880c4ace79853750121b72af8b0b8a5d19da70c3a4e0bf7176a03ace32f9eafce27b2b24cf5ef7481c68cee127562bc074149e66b30f35da8b9b2b50173801a0e89c100c1ca1c130a04b0acb4d4d81077b25b1fa3a2c55c667186dd68e8aec79ed09d7c5096c96246c4579862a95aedb6c46d72f96f83dcc1e1b4b6826bf537bfd64fe0062c71b39fcea1fe334a99fb1a1a614b17890359aca97943a837bf3a55ebe859ab3ce7b8de28e16805ed3a729be08fae0882ae3ff70899c85e233e434e93560e78e714668adb308a5ed0a60cd9d8f42dc8b6b33ce2372f5e6625c01a4c100c02a53a88760b9950128ea56599a818554b39fe3116177fb8e6032e72ed9af94684516c726b28684bda55964d8cab62c6a35b4f20db2c381488d8185c601d6f498f1c9441d457a482e18f52e9a607fc36f2aa36a373972cbb5459762082d945fce7431c7498ea675079ab81b297c8e700b70dcadb7e75fae276d2f14c5687243fd47565e629feafcf9ce17aecf8f9c9a87ae4cb12518735eeb34bb4f159d40c25b751e209af176e42d74bcb1384f06e9edbc238ee05edb91d406d5242ec499306c0e6d8930ce98bab8e89f8c0638b3b71f28965a5ab1d37abd68919f0c3589a70847af35541c7588d0ef053826f495d808397a2c50ba91d5f70deef7743def9995c8ad5cf2235308771ccdd915a6249b9fea19f41a5dc1249408f4efccc546a87ac2503d393b5dde043a5edebff5aae9bcc1d9d48979c53a74a5a5317f04a11efbeb73432a8f39ed932aa7e7b5bc2f685269ca8b3c18faeb4892c9f1481de8f30e1ad39a45b4159719ea785697ffe7099382c026efbf8161b647382923651f24aaf89e259e764dde1d98f38bc1e8b74cc1e04c08d197cd6659b246f5deca9fd7c463a1ad0b6368042c2dbd84ec195faa986ed6c151d7abe8f0e00c5bf25758b0b1de120375eeaaee3440937d5f09b57cdaf044edffbf050ba24b048f90c58e277f5f2988fd6cb6d8834505926d2fc26942700b491bd6104fbe47c25addb4bfce659ef001daca7545c722f9f5501596a8a71549fb435f43696e9c2faecb5e72d2b8ba8f71a46ccda8b846d53f4abfc5a56742c5e9b07ebda100f4d935274fb10a7f65f47c1a1bbc8585efe950e2d082d698a804df0b3f409201ae82280e46b8d3aa3fdda0ce544d12bc893f43791e9f527fdf773a8c84913c79db0ac9446d981552ab8703aefa31fb9b09751f39f4655f99980984b074939237097a0da713ca14c3ae02bb619540aea3d9a9b30deef510f2e9ee8d216a28fdabd0258155cbe640493554b2b51e2794e39907c8dc5baf6a9c0273d4f64839df14a6be3cafb88591077b27a980f5d923979122eeea3375680dc433930fc8b081688f2324cad4dcc9252166d5df592e44bce906b81a25b3dbe6ab0b14d3e04d7f1a70ed69f88b33029fa5695170bd492535eb8f91a1d271430e5d8335878b095ab920123fe0521e8688b832da83fcf4c87f2e8c7e016a9066290784de612faa6f6491f0e7ad647372db5c3456f930b95bd5b22abc845311da4d180895440c83f575f1750df79aa52c86fa0386e86b64191d055a0dc1ea30b28b6631cd8987f09e85ce6277b616bb2b6334f991c230d1bc774ec7dcc161bd2b762599d33e316df53a6f613c645494386bda0d709cf3ecbe94b77667844390e04d636cc4eabc83b57df82167e2ae1ec4a35451affb7c53358c81d87b8ae86811b4480ec0807a13d50766315e951de08f0b092610d39e07a88dbd052e2476a8b19a721773fe84978689d367cf53721be042a103b860cc84b91028044a9892bb0949b0853ed6c142d9330e78d34ee5d783b59af0cfa0a237f9de4ed3c94984ab5381320fea0e7463b46a845872641cf944032d12f2b300aa563a29e7f348d89c6f674a1229b7fc166d3e3c15b16f6662b327ab6eab43959ed9fdd7ce3ddd90ac8044d40c92319767cb186a72b959823ac613b3ce15ce1321c355edfacf3fdc5a7313e7ee51098a1957c2e51cfd216ead7f3c187e4d0b64aebe094bc702b14658ae5438f512a45cc5ab6135a0f7f8ca8c57b26f3d13d94bdd2e6b8be8ca7f02ec039eede91466a0c937a9c01b0d83ac31ae04417ca0bb5d6b5445b6de209fec70a5bd28e8f82be2d3d60b7829baeadbdd09bb4120c6d92a718d95f7805bae673c59721a90359eff880faba57627b40bc13073ac5daa4697307f2213609bccc38b688dbf49b5020a96f20bac7838e602968d213709279ef499aee7867e95738724be724fb2db8dc3fc659ee4a76ad8e1b82b4ebca11608f9e13b238a705f8011569680e8b5efd3fb72653bdc91a9de883c8fa397d4288c8093e1e81a7fbb62cdb34c99e30e2945b8dcbbdb55dac75699e796f61ceb74be08c81e3de5411aa91fd1a5662329c6113f7a909fef045056d43ca5e7a0bd320ec0ebcb73281b977ca99a5a4e041ed9d99a18eec9ad77c3c09f8d55b7abe6ba4a20521c1349e01d4e6d03839c55a487fdd43a84797aa6b3722be4867de085734c5cefa08b9aa0b767f493e6be9e37f04cfd4cd17a875369165752f5f6e8eb0bd72009d9b6ae8073b1da3992606859f16f34ad1c2ce21c4d25cf70f8821946f07ea4bc32b00e90101cdb4a88503af573c8e27c76fbb531731dd8d87f69f0dae88331fae23a4ddb47e190fb32921b5d7f3b3116287383bfc472646c8a1dfb9e642fa4f4ea62d2903a2bae98850846f4099481d66fec485fd8bd95efe9439a97393ed355e3cc1c4bb15f385433b7642306525b5f55aa8a9ed34acdbc7923d976417f56ba60acbd29d766538b1799fc2be7f62f679bd0ebae14b96258ab63471171c2aa389ae053cbfaf4d9c03748c40b6e5e8ad24c68bb777c456570fe48549855f4f0a13bc73c2fbea756082fb39031cad94ef9d4c187364e46a3a158cde23ada8e2c52b2a5d93fd91a76b110f2110bcb4afaf9cb2b276a5af726f20c548877aefef0289de9e36606cfe47c7bcb9757f020078c8a0dc14ad2ef5777a5a13898ab79f9b4f66c9cfa8e1b8874b3c006317e62373faf24d70eff5c2d35da63ed2b66aa38a5971f41d1c32e77e08b2d5539901ff7df42af72c6484ce02cd629533985eab3c6cee90de918fcc6f22ce88fcadfe863447db711b61d25244e395c1a90e471d0c45cf56ffc85a62a4ca7c53338131915836f831ac2b1639a6d063367a56013d31a59d42fd730ce09692d7650a2a48b4baf94663ebf04e6809b252ff0eb15dbd05f9ce6078a8190d3d1bba94aef498b7abe007708cbdd868e1e6700bc27f5279ce5bc67dbaf5b23c8fcaaa4b1baf2c3afe3d99a8bfe8413553c4fc74a328a6b26b6bdfca621cd820fda4e72977b3820acd9429804c423322e23e1436771772abcaeb053189cc862cd1edfc27e192463295bb12c4926e354a9bdf40b2e822135b3ce7d3deffc3d61a943a2915aef1aa7c51f39177dbdfbc30dde16c7a60f06f26a9bbcd9aee5dfd19d947c41d58215b365956f902e956fee2ec32297e74738b20d205b186181cc0cfb24969a4eeb89b749468150ba27534ee4467b21446eb3fbece4a9e61bfa1a7f70fd629c37901fcdd61c883a5758dc25dce0631f196ef508f9c7fb4222b7a8d5ac1a50e91bac6c62d708b63e05fa647768802f039c8acac169039bc9942c0bfdb9302cc09f20af5256a57d0228eedd9c138cd97de334aabafd73e49589fd3670e6c91fc3e7a61f63bdaa66c0519b3038e05125dc41be249dc0a1e50bc2da215d78e341161a8574d29fe277b11e8f98fa79b890a91bfcd2a06dc6a907f8b4b68c9db01522412bbede432c6808f54db5f139654a99eea92115247a69e77cdca64f77e04529eefd4469af14aeabcd90db48b6e43a119b67d7f981d380efad516d1b693e7e7000ca347b5744f4519b73ec75f9fe1c047d9c8261adf2a47101463bde8d3a7331cbf496cfcde81e3dd69fdae9b6d45f1f37c0c7e29a2e6963e2de2ac79fd9e538981a6e8ba6082248155e722d7a7d84fccd42a74885808314c7d64f51ac03e30473611e42267b6374e939fbd7db3c20ca3ff8004443280e9631c8cd37052bbd328945573387f2201e62d06f0f7c0d96a2c88ac7960da7087c624cd47d6f691b295326a66bd31a29634ac0231aae993184f650037bd35a186d8ee48846c815b855258adbec68d13dae4439ad1ca228ef7fef32f9883e093a08fcf90b485ddd60fdcaeffbd03530a75ba0782edc186f28facde7d27488599f371b91b6c8e8afb2d91ef57b4af1bffb95b71b66c8cee030d91d4b7da2404203bcb2ad56652526fba4960647978cb89250472952a1bd711519cbeb843bcac223e99837704715d7a34b02d53ae20b1f9bb674a6860de2774b60a2ca30df3f86b2f54190d287224ed9ab46a6ed6c18fe2b665571f78dc852e7ad3b99354441680d5ac18251de89e06b90ed2dccb2980f83ef6bc5edabf2bea3f809914f08f283f8ea0209345a7caf7183c5a8505a9eb3175c7787bb9a20046dfe455a96ee4a5c92c8192df042860630ce5eb6a9e579366354464b4804214165132eace7b15d6b6ec5800028df97b73f5b82f0d9fcf925d5c2a04ef4b3daa8af7c2b78dec0f5939e4276d4f2f17c3a99de5effb55d436807f0c763a5c93800a67c51c42e1d085d7599d85c80906a1f9d92fd3d15c83b764bc5a679cef89ccfd0447d1ab02756885330837b242d43ed4805fd0206e4ee871fec54b319b60c8e5ea94470a761a4223306cf38cd4cc7412948b86d5042a198a26531ddbd5a3d09464e54b2a4830931a9041c7f8262ad176996d6f90009309efe6fa84081e5eceaa5aa8132dbaa2b4a81b40758d80ce316253df9eba92f46862f19b9339830474049cb819690b12576761f5a7b05f74c37d0592f06dc7a2a3ee1b6193c17c275d8729b616902b1f028b298f25bf61ca0bcfbff2b83efef4ae91e50cb9cb4bf027893d010267c3313dec72998af0d79439f3541357e8aa4d76a4a4d1518744f81865680882f4b0e6d2e0b6f0ef88be0be6879963f850437f4317ca857de6ad0ceaf11cdff830caf57a02788165e5abb4bab9a67e96d074e2a75c3cd664d2905ecf8dff15588ad118d3841990b98afbce66f8ded87d8e2e4185076bf01821880dfdc8c094b71d998f80acdf8ece617a13cfa7311278ba8610777775a9c4e96c1a9ef8377c6eebf8d9ff2ff2fccd80c5792dc7c4c3d87c3f3306fe5cf66ea4817e7c9e853d779b9e9ef4933ebb888adb26fc9a5995237e829084a604bdbd1d4848ef264533c455337a9d21b3a1068b6377dc7ba467aaf9fc2a0311ba0b379d583475ee4d058c593886424501c9803db9efc1a5495cb2000826f60c414629e1793f3897f7557bfb13a790d1ef0d670d60cb12485b21a75a268b18e2ac3e5f788027e97ff65be0a65d30ca9f6eb6e00229d6bcffe309e140ce89fdda6cc4bfe5347d9a827f454b1998994d508d6fec7f2e751875981cf664195ac735e1d2740560cdc3c61694e0b5c736455b1a5add4ee11f612d78f8098811a443e89adf217a447b62833d4f06e6f1c7b55bb80f57a03f2b24a8649067198e375b2a91c6f17fe885626726682bbe38430a08121a298312abb03ec178e2c0bf53a9807b139c00b04e58561d20f6597ba5353b9c55a7ffe22c487e0dd315ae92ca70e729415074f5dfa7a2e46f59251c985a52bdde2ca2ad4b84fc832187ef1e7a6626d714f64d7ce203c0317213c83e0592dcf200dacee68539db0be3db307d202653a84b30d12f9fd752b74c3ae50b3b77c894624887bf77c5119dfeee523665ef83f5586774101c3b256ac5eed81dcefeae5dfc1376143383501d19bf87c5e8073708172bb7bf4ebe1d2bee4e04f4754c2017d2b4618dc7d3d4ba366d351153282257e81500347d4ceca47b73ed3c412758e31f9aa2c9603b956c8efd06b329e195180efa1fa4f59bd90b7ef498cc63e2038a20813f9a9956f80f4d2f6f6215c7f6341a05777e9918f36c2ad973b0e7fed4fe78f86c5bc0cb384448433c4acad782a98251a57a7c5451a7803988645edf2e409a8e8801aee2e78b525f01b9c635005af3ed921858e314db548f97f0b8502c91de37e24f9694c11b027a1e04c8856b25fdbbc5bf3d2f4de27520470b77cd5db50dc70b3ef2b8e0d21e818a7a574c62606ab8348c16a71caf2fbfe38e7d68416f779a6e4c819199acf10c506b6331acba580eec7d21a5659ed67821916bda7118ca179abeb2e59fa235180c916e0598b850482beb46da6f4bc6da81e3e74cd528f6455131fd311e695e4be1e1660980b9e7cb1a1678d9fb422e2c9eb852e7b93e33d0126a69989453f6003f0f4838e071f32373c4c98287702e285cef98379148d7396a9bc60e8e371ab18a1b85449fdd4163d6689571af3a6ba386241cfea1414fd29fce53af7173d6d13f9676220f443399e624cdee0c81004081a1bfff342f3dbc0e020030f9e69ae47ed3ab9f8dfecef8e337b3a47de1389e6a0ac0b7cd1b6e6ce079bb97dfee992f502c50d93e34a5bb16967aba30b0f48fdcd1c1dd7fdc4a04af32ea48c38e0fae0e1dbfdbe550e55d7553aaa7cb8a892efe91b137952cfd19f5e430f523d285f884f6fc5dfd0e957451b34f007909ce4d3da13b4a872783a557288da9f9592bbbabfadeaf5f84cd66c05e5b896edca881716c93f3138e4c7334cb3d2e21db4427cb218e77c758599fc69b94d1607c4a0b1d43d16e10909c558c7258fa7f782a8a353416b6e696ab26e7196b75c8a230a6d0387a4812872e4fe47f435d6731b72595316469b152a72bbffbd4e1090a29db045dd7d153fc03f7228fd1e295384af666a352be924f95361f199b0af5e93a1dbdce31a06a223f5f18f493e8b0775b0f8f601e8ea84aee2ba03e6ab83b4ddace28ff77e78c6fb757257abdebf072ece2fc6b620642a6afb873c1427780283967c7d3f06a46ad8434a9c2413d426eb6f029c143c7d837222f5aa1993c0eebfd4e7104cce308d309a0f85cda977168ad00ce46a094d2d9fb527373e0280f5ce7bda162d92a75bed0cc9e8eff7d389f084edc566b9abc8cc413e211bfaa98be1826672234274e227405eb90e060b852b26b4e60e2f54142761c4fc843d05e9edcb6c1f8e6f2c63901952e174357e0ee372a62b778b0c34869226e4412ae680b10d57ab8dcf6220f0f42ffd40c506a6690a3c66d57ea641bb856d576ac20e7651352830a7ef99416cbab82f4de5a7e408b312d262c38f66fe28afab6e195abcd21e6ded92c79640b26d5b5bca5d5020ecddaf2f07207d22f9f5ae05b5aef8da5924f3fcccda88f2dff1b208d7ae0a861feeab22e6bea150e4c6f1429dd420c5cb922c29f022861e5bc0ffb5c9fd9f4fa9c0a63787c0a0f69344c6e5f6831c47d6e372a9cce161ac26196f1004ef6d4a40690ad9765c9c31fc1239e0b96814b4b78e1d6f75aadddef66ce57cda7f216c04bd791fc1a474f60d6aed68372349f550213d8f40c93653d1ce7409114f04b159273740afb665b8e996001abcb1ff7b2004d669b717aba8db55b0defb1e08b37867374a6ff4e3ee5da6ccc735b9a0ee16b419456adc8dd581f9100e3b4a851425a19a84aac94d91c741592fe22bd8b3d23fd2cfb14cc25880ff7dbab8e0027c3b5c1372207fc2219eae6807363c2883616e6c3c756fbac3e58295c11a35c7c3a3d9f526b471173e25b6ff600f22e31596da29c31e2682dbfef06d2e7437b82a64844800f5e9c5b32f6fb43eb6aac5093aa4ad2694ea0c40843882f3c85f2589b46a29dcf5690003fbc2b122fd09ffa1c29cd62dd55404b87cf3c2642daabd48b85fed573907c242509a3b62dc6057eb994a2be8e8b1eb0d3c22db68575684d618ef845e0da6fcf4778685b93c0bddfed0bea9fc1010cc647a051fe2c29956fabb27cd842966075bfeb63d738aceb8d2c5faa6b5d73faaf700326b24b68aaa42e939dfecf08113360d51756f781226e29596b0586cfc70da1861d32aa83410d9306a61760278fac8f80cf960b9fffddeaa1cf74560134827f5ff1d956c9b4d9281789f7c050fb917eaec1fd87bf6bbf7d4bc28eeebb8b43e5ce2af7389d5a6191969e13737035bea9e3bc48da8c180774b955b20b6b548b5134adbffee05ad29a2fbda0c8c3ada19701776e03e0580350d0b709788987a4500c72cd3d65e3df9eaf9b6cdd52e7591ab37eaec8da199d5c2130d7c4eadf950b704b66feb1b270e39758a6f5362ef73ef0fd6edd7611c7c424591d22eeea755594f2bfa2f8bcf37cec985b5f20a4f23334277bf8004377ddba8a72faedd49a3a4b8ea5d6fe38a937905ea2f1d665fa8d69dbc9b60665433b92c03b4d1351748922d14feb691bf9760cbbae2dda74c8b9b6ed4065f5d608d68238c7b591fb8a23af7b091aefc633a185080509665c1d7eca30382291e82cd187452c1f8136a9985816dfabf541c7d87fac30b6b3df7562aa6f10b1dd0cd723194504449ddf07c9e9b8ad38f635f1fb5106b6ab1eee7739cbca6d927ddc26b7c5a3ed12f2936c73681ca7e11223472b78cd1fe3f8bf8a3671a9373463a5ca05457c3e531c7dc6d109291da4ce0fc9d2dd8b0b03f4e41ccc47a24ebc2ac79407e1d95d1fd0cbcc430547bcf4064659636ea355af21a75cd5f342deb90ad152e33728ecfa7b5663feed5a84ad8f875330af2b4d8683035f39e5bcd0c17266ba18bcbd38720b23020f8c6c1a9afa955a8e00b558b4cb23d32c8cc72844be10282ffc0aec932b59c7edfe6b7044797dad6b6e24ae2d9ab35c4d9ba6f7ca4915ebaa54f7ea61754c52b7f756f5168a10749926aeaae948da1e74626170646a2b8b2ba5f85df136dcc2828471655182c2cf6adca4a719db970a989cec2cdeea033133d1822102b27b7b33f78470aaf7b550eb468944b6731f4b11053c4c0002d0e63ad89b21a28c424ed9cf84aca72825dc401a06b7a50f6a3f028c25f74f61c224825cd2eadb867a49c168895f803a3fcc2c2569965ed7fa3d769fe2588fd9858f95606f4d40554c2e501e50da60ea5638458cc4ffe9ebf0aa46f46eccf070f4b0752b4a969bb6055eef07bd1b80dcf8ac1ed13da1b998b7d0ab2742c169454e238b80065e1cbcabd1800b18e90a0291e05968c18c001cabb6e9badfd98bb2c07e7b9270089b4aa104f328997be83b6122dbe327e493221de1edc4bf58df988254fa95dcdf66edcbc4a4fa337768fec817b8305d6e87e4f781a061d7bc61de071957bc21154563f54b47d988fa5e9906a028b5b7d58b894898e9837e5cf96c3e4f6a09c7deb04a9d2348eda6b6d531ebb697cc1c77fda39779bc0d44ed5bbb7004bf6a36c4a673462e2cc8785de7b3c4e7713946427df5a3e49eddd4ed9bd663f4f2a79af648c0adbd1141f4226e5f1a1609288bc1db413808c31f7d356f676e7ba64539dd659e5f7571f8db02efe005fffa6284568d52ea8a0d76243d7858864ece2818452f9ea7096e0024e4450d22c7674</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo基础</title>
    <url>/2021/04/16/direction-for-use/</url>
    <content><![CDATA[<p> Hexo基础命令。常用功能的添加与修改等内容。</p>
<p>博客入门期间所整理。</p>
<span id="more"></span>
<h2 id="Hexo基础"><a href="#Hexo基础" class="headerlink" title="Hexo基础"></a>Hexo基础</h2><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new &lt;title&gt;      <span class="comment"># 创建新文章 目录于 \source\_post 下</span></span><br><span class="line">$ hexo new post &lt;title&gt; <span class="comment"># 创建新文章 目录于 \source\_post 下</span></span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo server   <span class="comment"># hexo s</span></span><br><span class="line">$ hexo generate <span class="comment"># hexo g</span></span><br><span class="line">$ hexo deploy   <span class="comment"># hexo d</span></span><br></pre></td></tr></table></figure>
<p>文件头所包含内容</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标题</span><br><span class="line">urlname: URL内容</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">-</span> tag1</span><br><span class="line"><span class="bullet">-</span> tag2</span><br><span class="line">mathjax: true/false</span><br><span class="line">description: 概述</span><br><span class="line">passward: 密码内容</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line"><span class="comment"># 解决方案</span></span><br><span class="line">$ git config --global http.sslVerify <span class="string">&quot;false&quot;</span></span><br><span class="line"></span><br><span class="line">Failed to connect to github.com port 443: Timed out</span><br><span class="line"><span class="comment"># 解决方案</span></span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line">$ git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">$ git config --global --<span class="built_in">unset</span> https.proxy</span><br><span class="line"></span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br><span class="line">Everything up-to-date</span><br><span class="line"><span class="comment"># 解决方案</span></span><br><span class="line"><span class="comment"># 尚不明确 重新链接网络</span></span><br></pre></td></tr></table></figure>
<h3 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h3><p>\hexo\_config.yml hexo站点配置解析，参考：</p>
<p><a href="https://blog.csdn.net/loze/article/details/94209583">https://blog.csdn.net/loze/article/details/94209583</a></p>
<p>\hexo\themes\next\_config.yml next主题配置解析，参考：</p>
<p><a href="https://blog.csdn.net/loze/article/details/94210320">https://blog.csdn.net/loze/article/details/94210320</a></p>
<h3 id="修改页面图标"><a href="#修改页面图标" class="headerlink" title="修改页面图标"></a>修改页面图标</h3><p>放置图标的位置为 \theme\next\sources\images 目录下，需要 small 和 medium 两种。</p>
<p>在 themes\next\_config.yml 的 favicon 处修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/yjq.ico</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/yjq.jpg</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>
<h3 id="修改menu"><a href="#修改menu" class="headerlink" title="修改menu"></a>修改menu</h3><p>在 themes\next\_config.yml 的 menu 处修改，删除部分 # 以开启功能。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. yoursite.com/blog), remove the leading slash from link value (/archives -&gt; archives).</span></span><br><span class="line"><span class="comment"># External url should start with http:// or https://</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Enable / Disable menu icons / item badges.</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>接下来需要创建相关页面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;about&quot;</span></span><br><span class="line">$ hexo new page <span class="string">&quot;tags&quot;</span></span><br><span class="line">$ hexo new page <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure>
<p>在生成的 markdown 文件中作出修改：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2019-06-25 19:16:17</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>tag 与 categories 的修改类似。</p>
<h3 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h3><p>在 _config.yml 的 # URL 处做出如下修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://xiaoq-sd.github.io/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:urlname/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line">  <span class="attr">urlname:</span> <span class="string">index</span> <span class="comment"># 添加默认</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure>
<p>默认使用 :title 生成URL，但 title 的名称可能会是中文。</p>
<p>不妨添加一个 urlname，用以生成 URL。</p>
<p>因此，在文章中应添加：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo基础</span><br><span class="line">urlname: direction-for-use</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="配置搜索文件"><a href="#配置搜索文件" class="headerlink" title="配置搜索文件"></a>配置搜索文件</h3><p>首先安装插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>在 _config.yml 的 # Extensions 后面添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>在 themes\next\_config.yml 的 Local Search 处修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 此处修改为 true</span></span><br></pre></td></tr></table></figure>
<h3 id="文章字数统计，阅读时长"><a href="#文章字数统计，阅读时长" class="headerlink" title="文章字数统计，阅读时长"></a>文章字数统计，阅读时长</h3><p>添加插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install eslint --save</span><br><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件 _config,yml 处添加<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计单词数量</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>在 themes\next\_config.yml 的 # post wordcount 处修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><p>文章截断方法，在需要截断的地方添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure>
<p>文章首部写概述</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">description: 概述位置</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="统计访客"><a href="#统计访客" class="headerlink" title="统计访客"></a>统计访客</h3><p>在 themes\next\_config.yml 的 busuanzi_count 处修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>
<h3 id="加密文章设置"><a href="#加密文章设置" class="headerlink" title="加密文章设置"></a>加密文章设置</h3><p>来自：<a href="https://zhuanlan.zhihu.com/p/113235573">https://zhuanlan.zhihu.com/p/113235573</a></p>
<p>安装插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-blog-encrypt</span><br></pre></td></tr></table></figure>
<p>在 _config.yml 中添加如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安全</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">这篇文章被加密了，需要输入密码查看哦。</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码A</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码B</span>&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="string">&lt;div</span> <span class="string">id=&quot;hexo-blog-encrypt&quot;</span> <span class="string">data-wpm=&quot;&#123;&#123;hbeWrongPassMessage&#125;&#125;&quot;</span> <span class="string">data-whm=&quot;&#123;&#123;hbeWrongHashMessage&#125;&#125;&quot;&gt;&lt;div</span> <span class="string">class=&quot;hbe-input-container&quot;&gt;&lt;input</span> <span class="string">type=&quot;password&quot;</span> <span class="string">id=&quot;hbePass&quot;</span> <span class="string">placeholder=&quot;&#123;&#123;hbeMessage&#125;&#125;&quot;</span> <span class="string">/&gt;&lt;label&gt;&#123;&#123;hbeMessage&#125;&#125;&lt;/label&gt;&lt;div</span> <span class="string">class=&quot;bottom-line&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script</span> <span class="string">id=&quot;hbeData&quot;</span> <span class="string">type=&quot;hbeData&quot;</span> <span class="string">data-hmacdigest=&quot;&#123;&#123;hbeHmacDigest&#125;&#125;&quot;&gt;&#123;&#123;hbeEncryptedData&#125;&#125;&lt;/script&gt;&lt;/div&gt;</span></span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br></pre></td></tr></table></figure>
<p>在所需加密的文章中，文章头部改为如下内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: passwordtest</span><br><span class="line">date: 2021-04-20 20:24:13</span><br><span class="line">password: password</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="百度自动推送设置"><a href="#百度自动推送设置" class="headerlink" title="百度自动推送设置"></a>百度自动推送设置</h3><p>安装插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-baidu-url-submit --save</span><br><span class="line">$ npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">$ npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<p>于 _config.yml 中修改如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 百度自动提交</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">5</span> 				            <span class="comment"># 提交最新的五个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">https://xiaoq-sd.github.io/</span> <span class="comment"># 百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">eD5NHy*********</span>	        <span class="comment"># 准入秘钥</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span>              <span class="comment"># 文本文档的地址 新链接会保存在此文本文档里</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动生成sitemap</span></span><br><span class="line">  <span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line">  <span class="attr">baidusitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/XiaoQ-SD/XiaoQ-SD.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">leancloud_counter_security_sync</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将 next 主题配置文件中的 baidu_push 设为 true。<br>在 baidu_site_verification 处写上准入token</p>
]]></content>
      <tags>
        <tag>blogs</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM 模板整理</title>
    <url>/2021/04/20/ACM-templates/</url>
    <content><![CDATA[<p>本文包含2017 - 2020 ACM竞赛期间的算法整理。</p>
<p>内容包括：</p>
<ol>
<li>Java &amp; C++</li>
<li>数学</li>
<li>图论</li>
<li>数据结构</li>
<li>动态规划</li>
<li>其它问题</li>
<li>组合数学</li>
<li>博弈问题</li>
</ol>
<span id="more"></span>
<h2 id="Java-amp-C"><a href="#Java-amp-C" class="headerlink" title="Java &amp; C++"></a>Java &amp; C++</h2><h3 id="Java快速I-O"><a href="#Java快速I-O" class="headerlink" title="Java快速I/O"></a>Java快速I/O</h3><h4 id="个人常用模板"><a href="#个人常用模板" class="headerlink" title="个人常用模板"></a>个人常用模板</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> StreamTokenizer in = <span class="keyword">new</span> StreamTokenizer(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)));</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        in.nextToken();</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) in.nval;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        in.nextToken();</span><br><span class="line">        <span class="keyword">return</span> in.nval;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        in.nextToken();</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) in.nval;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        in.nextToken();</span><br><span class="line">        <span class="keyword">return</span> in.sval;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-1-2-CF上的快速I-O（速度最快？？？）"><a href="#0-1-2-CF上的快速I-O（速度最快？？？）" class="headerlink" title="0.1.2 CF上的快速I/O（速度最快？？？）"></a>0.1.2 CF上的快速I/O（速度最快？？？）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	  <span class="comment">/*</span></span><br><span class="line"><span class="comment">	   写代码</span></span><br><span class="line"><span class="comment">	  */</span></span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> FastReader in = <span class="keyword">new</span> FastReader();</span><br><span class="line">    <span class="keyword">static</span> PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FastReader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> InputStream mIs;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> curChar, numChars;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FastReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(System.in);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FastReader</span><span class="params">(InputStream is)</span> </span>&#123;</span><br><span class="line">            mIs = is;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (numChars == -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> InputMismatchException();</span><br><span class="line">            <span class="keyword">if</span> (curChar &gt;= numChars) &#123;</span><br><span class="line">                curChar = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    numChars = mIs.read(buf);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InputMismatchException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (numChars &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> buf[curChar++];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">nextLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = read();</span><br><span class="line">            <span class="keyword">while</span> (isSpaceChar(c)) c = read();</span><br><span class="line">            StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                res.appendCodePoint(c);</span><br><span class="line">                c = read();</span><br><span class="line">            &#125; <span class="keyword">while</span> (!isEndOfLine(c));</span><br><span class="line">            <span class="keyword">return</span> res.toString();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = read();</span><br><span class="line">            <span class="keyword">while</span> (isSpaceChar(c)) c = read();</span><br><span class="line">            StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                res.appendCodePoint(c);</span><br><span class="line">                c = read();</span><br><span class="line">            &#125; <span class="keyword">while</span> (!isSpaceChar(c));</span><br><span class="line">            <span class="keyword">return</span> res.toString();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = read();</span><br><span class="line">            <span class="keyword">while</span> (isSpaceChar(c)) c = read();</span><br><span class="line">            <span class="keyword">int</span> sgn = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                sgn = -<span class="number">1</span>;</span><br><span class="line">                c = read();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> InputMismatchException();</span><br><span class="line">                res *= <span class="number">10</span>;</span><br><span class="line">                res += c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                c = read();</span><br><span class="line">            &#125; <span class="keyword">while</span> (!isSpaceChar(c));</span><br><span class="line">            <span class="keyword">return</span> res * sgn;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = read();</span><br><span class="line">            <span class="keyword">while</span> (isSpaceChar(c)) c = read();</span><br><span class="line">            <span class="keyword">int</span> sgn = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                sgn = -<span class="number">1</span>;</span><br><span class="line">                c = read();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> InputMismatchException();</span><br><span class="line">                res *= <span class="number">10</span>;</span><br><span class="line">                res += c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                c = read();</span><br><span class="line">            &#125; <span class="keyword">while</span> (!isSpaceChar(c));</span><br><span class="line">            <span class="keyword">return</span> res * sgn;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.parseDouble(next());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSpaceChar</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c == <span class="string">&#x27; &#x27;</span> || c == <span class="string">&#x27;\n&#x27;</span> || c == <span class="string">&#x27;\r&#x27;</span> || c == <span class="string">&#x27;\t&#x27;</span> || c == -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEndOfLine</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c == <span class="string">&#x27;\n&#x27;</span> || c == <span class="string">&#x27;\r&#x27;</span> || c == -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanIntArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> li = <span class="number">0</span>; li &lt; arr.length; ++li) &#123;</span><br><span class="line">                arr[li] = nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanLongArr</span><span class="params">(<span class="keyword">long</span>[] arr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">                arr[i] = nextLong();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = (<span class="keyword">int</span>) (Math.random() * i);</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i - <span class="number">1</span>];</span><br><span class="line">                arr[i - <span class="number">1</span>] = arr[r];</span><br><span class="line">                arr[r] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Petr的快速IO"><a href="#Petr的快速IO" class="headerlink" title="Petr的快速IO"></a>Petr的快速IO</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> InputReader in = <span class="keyword">new</span> InputReader(System.in);</span><br><span class="line">    <span class="keyword">static</span> PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InputReader</span> </span>&#123;</span><br><span class="line">        BufferedReader br;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InputReader</span><span class="params">(InputStream stream)</span> </span>&#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(stream));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = br.read();</span><br><span class="line">            <span class="keyword">while</span> (c &lt;= <span class="number">32</span>) &#123;</span><br><span class="line">                c = br.read();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                negative = <span class="keyword">true</span>;</span><br><span class="line">                c = br.read();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (c &gt; <span class="number">32</span>) &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                c = br.read();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> negative ? -x : x;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = br.read();</span><br><span class="line">            <span class="keyword">while</span> (c &lt;= <span class="number">32</span>) &#123;</span><br><span class="line">                c = br.read();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                negative = <span class="keyword">true</span>;</span><br><span class="line">                c = br.read();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (c &gt; <span class="number">32</span>) &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                c = br.read();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> negative ? -x : x;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = br.read();</span><br><span class="line">            <span class="keyword">while</span> (c &lt;= <span class="number">32</span>) &#123;</span><br><span class="line">                c = br.read();</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> (c &gt; <span class="number">32</span>) &#123;</span><br><span class="line">                sb.append((<span class="keyword">char</span>) c);</span><br><span class="line">                c = br.read();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.parseDouble(next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="0-1-4-常用快速IO"><a href="#0-1-4-常用快速IO" class="headerlink" title="0.1.4 常用快速IO"></a>0.1.4 常用快速IO</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">import</span> java.rmi.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="keyword">static</span> StringTokenizer tok;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (tok == <span class="keyword">null</span> || !tok.hasMoreTokens())</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                tok = <span class="keyword">new</span> StringTokenizer(in.readLine());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hasNext();</span><br><span class="line">        <span class="keyword">return</span> tok.nextToken();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">nextLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> in.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(next());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(next());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-STL"><a href="#C-STL" class="headerlink" title="C++ STL"></a>C++ STL</h3><h4 id="lower-bound-amp-upper-bound"><a href="#lower-bound-amp-upper-bound" class="headerlink" title="lower_bound&amp;upper_bound"></a>lower_bound&amp;upper_bound</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    lower_bound()    返回键值&gt;=给定元素的第一个位置</span></span><br><span class="line"><span class="comment">    upper_bound()     返回键值&gt;给定元素的第一个位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//函数版a[1,...,n]中查找元素x</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, x) - a;</span><br><span class="line"><span class="comment">//pos为第一个大于x的数所在的地址</span></span><br><span class="line"><span class="comment">//若x大于a中所有数，则pos&gt;n;若x小于所有数则pos&lt;=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector版</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), x) - v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//若x不存在，则返回v.begin()或v.end()</span></span><br><span class="line"><span class="comment">//二者得到的pos相减即可得出x在数组中出现的次数</span></span><br></pre></td></tr></table></figure>
<h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优先队列定义越小的优先级越大的</span></span><br><span class="line"><span class="comment">//注意：后面的两个&#x27;&gt;&#x27;之间要加空格</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问set中的元素（迭代器）</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    map中的成员函数：</span></span><br><span class="line"><span class="comment">        clear()清空</span></span><br><span class="line"><span class="comment">        count(x)返回x的出现次数</span></span><br><span class="line"><span class="comment">        empty()返回是否为空</span></span><br><span class="line"><span class="comment">        size()返回元素个数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设映射为m[x]=y</span></span><br><span class="line"><span class="comment">    find(x)返回该映射的迭代器</span></span><br><span class="line"><span class="comment">    同样支持lower_bound和upper_bound</span></span><br><span class="line"><span class="comment">    erease(it)删除迭代器it所指向的映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">find</span>(x);</span><br><span class="line">    m.<span class="built_in">erase</span>(it);<span class="comment">//清除m[x]=y</span></span><br><span class="line">    <span class="comment">//用迭代器访问m中的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//it-&gt;first表示x，it-&gt;second表示y</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="sort-amp-permutation"><a href="#sort-amp-permutation" class="headerlink" title="sort&amp;permutation"></a>sort&amp;permutation</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        next_permutation 下一个排列</span></span><br><span class="line"><span class="comment">        prev_permutation 前一个排列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        stable_sort() 对给定区间所有元素进行稳定排序</span></span><br><span class="line"><span class="comment">        vector set等均可通过sort进行排序，其默认优先级为：</span></span><br><span class="line"><span class="comment">                [例]</span></span><br><span class="line"><span class="comment">                &#123;-3,-2&#125;</span></span><br><span class="line"><span class="comment">                &#123;-3,-2,-1&#125;</span></span><br><span class="line"><span class="comment">                &#123;1,2,3,4,6&#125;</span></span><br><span class="line"><span class="comment">                &#123;1,2,6,9&#125;</span></span><br><span class="line"><span class="comment">                &#123;2,3,6,7,8&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="builtin-popcount"><a href="#builtin-popcount" class="headerlink" title="__builtin_popcount"></a>__builtin_popcount</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__builtin_popcount(x);</span><br></pre></td></tr></table></figure>
<p>精确得到变量x在二进制意义下的1的个数。</p>
<h3 id="C-快速读入"><a href="#C-快速读入" class="headerlink" title="C++快速读入"></a>C++快速读入</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">100000</span>, stdin), p1 == p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> _read(ll &amp;sum) &#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">nc</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>))ch = <span class="built_in">nc</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)sum = sum * <span class="number">10</span> + ch - <span class="number">48</span>, ch = <span class="built_in">nc</span>();</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h4><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include &lt;bits/stdc++.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">define ll <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">define ull <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line"><span class="function">define __ <span class="title">ios::sync_with_stdio</span><span class="params">(<span class="number">0</span>)</span></span>;cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[j][i]) - <span class="built_in">fabs</span>(a[r][i]) &gt;= eps)r = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j)</span><br><span class="line">            <span class="built_in">swap</span>(a[i][j], a[r][j]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[r][r]) &lt;= eps) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No Solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            a[i][j] /= a[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; ++k) &#123;</span><br><span class="line">                    a[j][k] -= a[j][i] * a[i][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; a[i][n + <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span> &#123;</span></span><br><span class="line">    ll num[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> m, mod;<span class="comment">//需要赋初值或设为全局变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">matrix</span>() &#123; <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span> num); &#125;</span><br><span class="line"></span><br><span class="line">    matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> matrix &amp;x) &#123;</span><br><span class="line">        matrix c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">                    c.num[i][j] = (c.num[i][j] + num[i][k] * x.num[k][j] + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> matrix &amp;x) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                num[i][j] = x.num[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">pow_mod</span><span class="params">(matrix &amp;x, ll k)</span> </span>&#123;</span><br><span class="line">    matrix ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x.m; ++i) &#123;</span><br><span class="line">        ans.num[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)ans = ans * x;</span><br><span class="line">        x = x * x;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整除与剩余"><a href="#整除与剩余" class="headerlink" title="整除与剩余"></a>整除与剩余</h3><h4 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123; <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); &#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h4><p>求取 $ax + by = gcd(a, b)$</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">e_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">e_gcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    解得ax+by=gcd(a,b)的值，特解:</span></span><br><span class="line"><span class="comment">        x0 = x * c / gcd(a, b);</span></span><br><span class="line"><span class="comment">        y0 = y * c / gcd(a, b);</span></span><br><span class="line"><span class="comment">    所有解即为:</span></span><br><span class="line"><span class="comment">        x = x0 + k * b / gcd(a, b);</span></span><br><span class="line"><span class="comment">        y = y0 - k * a / gcd(a, b);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="线性乘法逆元"><a href="#线性乘法逆元" class="headerlink" title="线性乘法逆元"></a>线性乘法逆元</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1 - n的乘法逆元,m为模数*/</span></span><br><span class="line">    ni[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ni[i] = (m - m / i) * ni[m % i] % m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><h4 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h4><p>线性筛素数O(n)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn], tot;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) &#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            ans[tot] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; ((j &lt;= tot) &amp;&amp; (i * ans[j] &lt;= n)); ++j) &#123;</span><br><span class="line">            vis[i * ans[j]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % ans[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h4><p>素数测试（Miller-Rabin算法）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">mult_mod</span><span class="params">(ll a, ll b, ll c)</span> </span>&#123;</span><br><span class="line">    a %= c;</span><br><span class="line">    b %= c;</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    ll tmp = a;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ret += tmp;</span><br><span class="line">            <span class="keyword">if</span> (ret &gt; c) ret -= c;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; c) tmp -= c;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)ans = ans * a % m;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a, ll n, ll x, ll t)</span> </span>&#123;</span><br><span class="line">    ll ret = <span class="built_in">pow_mod</span>(a, x, n);</span><br><span class="line">    ll last = ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        ret = <span class="built_in">mult_mod</span>(ret, ret, n);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">1</span> &amp;&amp; last != <span class="number">1</span> &amp;&amp; last != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        last = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">20</span>;<span class="comment">//测试次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ll x = n - <span class="number">1</span>;</span><br><span class="line">    ll t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((x &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        t++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">        ll a = <span class="built_in">rand</span>() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(a, n, x, t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	质因数分解：</span></span><br><span class="line"><span class="comment">		n表示待分解的整数</span></span><br><span class="line"><span class="comment">		&amp;tot表示不同质因数的个数</span></span><br><span class="line"><span class="comment">		p[i]表示第i个质因数的值</span></span><br><span class="line"><span class="comment">		q[i]表示第i个质因数的指数</span></span><br><span class="line"><span class="comment">    调用方式 factor(n,p,q,tot);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">factor</span><span class="params">(ll n, ll *p, ll *q, <span class="keyword">int</span> &amp;tot)</span> </span>&#123;</span><br><span class="line">    ll temp, now;</span><br><span class="line">    temp = (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(n);</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    now = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= temp; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (now % i == <span class="number">0</span>) &#123;</span><br><span class="line">            p[++tot] = i;</span><br><span class="line">            q[tot] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (now % i == <span class="number">0</span>) &#123;</span><br><span class="line">                ++q[tot];</span><br><span class="line">                now /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now != <span class="number">1</span>) &#123;</span><br><span class="line">        p[++tot] = now;</span><br><span class="line">        q[tot] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><h4 id="计算欧拉函数"><a href="#计算欧拉函数" class="headerlink" title="计算欧拉函数"></a>计算欧拉函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="筛法构造欧拉函数表"><a href="#筛法构造欧拉函数表" class="headerlink" title="筛法构造欧拉函数表"></a>筛法构造欧拉函数表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_table</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!phi[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!phi[j])phi[j] = j;</span><br><span class="line">                phi[j] = (phi[j] / i) * (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">define ll <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)ans = ans * a % m;</span><br><span class="line">        a = a * a % m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h4><p>卢卡斯定理求 $C_n^m \% p$ 的值<br>注意：$ p$ 一定为一个不大的素数<br><strong>先调用init(<em>p</em>);计算所有阶乘的值</strong><br>然后lucas(n,m,<em>p</em>)即为所求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; ++i)</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * i % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)ans = ans * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lucas</span><span class="params">(ll n, ll m, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &amp;&amp; m) &#123;</span><br><span class="line">        ll a = n % p, b = m % p;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ans = ans * f[a] % p * <span class="built_in">pow_mod</span>(f[b] * f[a - b] % p, p - <span class="number">2</span>, p) % p;</span><br><span class="line">        n /= p;</span><br><span class="line">        m /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="高精度整数（Java）"><a href="#高精度整数（Java）" class="headerlink" title="高精度整数（Java）"></a>高精度整数（Java）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Scanner cin = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        BigInteger a, b;</span><br><span class="line">        <span class="comment">//以文件EOF结束</span></span><br><span class="line">        <span class="keyword">while</span> (cin.hasNext()) &#123;</span><br><span class="line">            a = cin.nextBigInteger();</span><br><span class="line">            b = cin.nextBigInteger();</span><br><span class="line"> </span><br><span class="line">            System.out.println(a.add(b)); <span class="comment">//大整数加法</span></span><br><span class="line">            System.out.println(a.subtract(b)); <span class="comment">//大整数减法</span></span><br><span class="line">            System.out.println(a.multiply(b)); <span class="comment">//大整数乘法</span></span><br><span class="line">            System.out.println(a.divide(b)); <span class="comment">//大整数除法(取整)</span></span><br><span class="line">            System.out.println(a.remainder(b)); <span class="comment">//大整数取模</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">//大整数的比较</span></span><br><span class="line">            <span class="keyword">if</span> (a.compareTo(b) == <span class="number">0</span>) System.out.println(<span class="string">&quot;a == b&quot;</span>); <span class="comment">//大整数a==b</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.compareTo(b) &gt; <span class="number">0</span>) System.out.println(<span class="string">&quot;a &gt; b&quot;</span>); <span class="comment">//大整数a&gt;b</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.compareTo(b) &lt; <span class="number">0</span>) System.out.println(<span class="string">&quot;a &lt; b&quot;</span>); <span class="comment">//大整数a&lt;b</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">//大整数绝对值</span></span><br><span class="line">            System.out.println(a.abs()); <span class="comment">//大整数a的绝对值</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">//大整数的幂</span></span><br><span class="line">            <span class="keyword">int</span> exponent = <span class="number">10</span>;</span><br><span class="line">            System.out.println(a.pow(exponent)); <span class="comment">//大整数a的exponent次幂</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">//返回大整数十进制的字符串表示</span></span><br><span class="line">            System.out.println(a.toString());</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//返回大整数p进制的字符串表示</span></span><br><span class="line">            <span class="keyword">int</span> p = <span class="number">8</span>;</span><br><span class="line">            System.out.println(a.toString(p));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="斐波那契数列求循环节"><a href="#斐波那契数列求循环节" class="headerlink" title="斐波那契数列求循环节"></a>斐波那契数列求循环节</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先调用getprime()</span></span><br><span class="line"></span><br><span class="line">define ll <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    ll mat[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Matrix</span>() &#123; <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="keyword">sizeof</span> mat); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">mul_M</span><span class="params">(Matrix a, Matrix b, ll mod)</span> </span>&#123;</span><br><span class="line">    Matrix ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            ans.mat[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j] % mod;</span><br><span class="line">                <span class="keyword">if</span> (ans.mat[i][j] &gt;= mod)ans.mat[i][j] -= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">pow_M</span><span class="params">(Matrix a, ll n, ll mod)</span> </span>&#123;</span><br><span class="line">    Matrix ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) ans.mat[i][i] = <span class="number">1</span>;</span><br><span class="line">    Matrix tmp = a;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)ans = <span class="built_in">mul_M</span>(ans, tmp, mod);</span><br><span class="line">        tmp = <span class="built_in">mul_M</span>(tmp, tmp, mod);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">pow_m</span><span class="params">(ll a, ll n, ll mod)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>, tmp = a % mod;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)ans = ans * tmp % mod;</span><br><span class="line">        tmp = tmp * tmp % mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getprime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(prime, <span class="number">0</span>, <span class="keyword">sizeof</span> prime);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!prime[i])prime[++prime[<span class="number">0</span>]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= prime[<span class="number">0</span>] &amp;&amp; prime[j] * i &lt;= maxn; ++j) &#123;</span><br><span class="line">            prime[prime[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll factor[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> fatcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfactors</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    fatcnt = <span class="number">0</span>;</span><br><span class="line">    ll tmp = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; prime[i] * prime[i] &lt;= tmp; ++i) &#123;</span><br><span class="line">        factor[fatcnt][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tmp % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            factor[fatcnt][<span class="number">0</span>] = prime[i];</span><br><span class="line">            <span class="keyword">while</span> (tmp % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                factor[fatcnt][<span class="number">1</span>]++;</span><br><span class="line">                tmp /= prime[i];</span><br><span class="line">            &#125;</span><br><span class="line">            fatcnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="number">1</span>) &#123;</span><br><span class="line">        factor[fatcnt][<span class="number">0</span>] = tmp;</span><br><span class="line">        factor[fatcnt++][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fatcnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">legendre</span><span class="params">(ll a, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pow_m</span>(a, (p - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>, p) == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f0 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getfib</span><span class="params">(ll n, ll mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mod == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Matrix A;</span><br><span class="line">    A.mat[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    A.mat[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    A.mat[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    A.mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Matrix B = <span class="built_in">pow_M</span>(A, n, mod);</span><br><span class="line">    ll ans = f0 * B.mat[<span class="number">0</span>][<span class="number">0</span>] + f1 * B.mat[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll fac[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">G</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">    ll num;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">legendre</span>(<span class="number">5</span>, p) == <span class="number">1</span>)num = p - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> num = <span class="number">2</span> * (p + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i * i &lt;= num; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            fac[cnt++] = i;</span><br><span class="line">            <span class="keyword">if</span> (i * i != num) &#123;</span><br><span class="line">                fac[cnt++] = num / i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(fac, fac + cnt);</span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getfib</span>(fac[i], p) == f0 &amp;&amp; <span class="built_in">getfib</span>(fac[i] + <span class="number">1</span>, p) == f1) &#123;</span><br><span class="line">            ans = fac[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">find_loop</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getfactors</span>(n);</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fatcnt; ++i) &#123;</span><br><span class="line">        ll record = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (factor[i][<span class="number">0</span>] == <span class="number">2</span>)record = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (factor[i][<span class="number">0</span>] == <span class="number">3</span>)record = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (factor[i][<span class="number">0</span>] == <span class="number">5</span>)record = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">else</span> record = <span class="built_in">G</span>(factor[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; factor[i][<span class="number">1</span>]; ++j) &#123;</span><br><span class="line">            record *= factor[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">lcm</span>(ans, record);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h4><p>stl complex<double>实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ld PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line">define cp complex&lt;<span class="keyword">double</span>&gt;</span><br><span class="line"><span class="keyword">int</span> rev[maxn], ans[maxn];</span><br><span class="line">cp A[maxn], B[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(cp *a, <span class="keyword">int</span> n, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; n)++bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="function">cp <span class="title">unit</span><span class="params">(cos(PI / mid), inv * sin(PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">            <span class="function">cp <span class="title">omega</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j, omega *= unit) &#123;</span><br><span class="line">                cp x = a[i + j], y = omega * a[i + j + mid];</span><br><span class="line">                a[i + j] = x + y;</span><br><span class="line">                a[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inv == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)a[i] /= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use FFT</span></span><br><span class="line"><span class="comment">// Array A[0...n-1]</span></span><br><span class="line"><span class="comment">// Array B[0...m-1]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bitn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (bitn &lt; n + m)bitn &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">FFT</span>(A, bitn, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(B, bitn, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitn; ++i) &#123;</span><br><span class="line">        A[i] = A[i] * B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FFT</span>(A, bitn, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        ans[i] += (<span class="keyword">int</span>) (A[i].<span class="built_in">real</span>() + <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>手写complex：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> _x = <span class="number">0.0</span>, <span class="keyword">double</span> _y = <span class="number">0.0</span>) &#123;</span><br><span class="line">        x = _x;</span><br><span class="line">        y = _y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(x - b.x, y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(x + b.x, y + b.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(x * b.x - y * b.y, x * b.y + y * b.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rev[maxn];</span><br><span class="line"></span><br><span class="line">define cp Complex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(cp *a, <span class="keyword">int</span> n, <span class="keyword">int</span> inv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; bit) &lt; n)++bit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])<span class="built_in">swap</span>(a[i], a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="function">cp <span class="title">unit</span><span class="params">(cos(PI / mid), inv * sin(PI / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += len) &#123;</span><br><span class="line">            <span class="function">cp <span class="title">omega</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j, omega = omega * unit) &#123;</span><br><span class="line">                cp x = a[i + j], y = omega * a[i + j + mid];</span><br><span class="line">                a[i + j] = x + y;</span><br><span class="line">                a[i + j + mid] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inv == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)a[i].x /= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="FWT"><a href="#FWT" class="headerlink" title="FWT"></a>FWT</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> OR = <span class="number">1</span>, AND = <span class="number">2</span>, XOR = <span class="number">3</span>, XNOR = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x += y) &gt;= mod ? x - mod : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x -= y) &lt; <span class="number">0</span> ? x + mod : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwt</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> rev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; n; d &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = d &lt;&lt; <span class="number">1</span>, i = <span class="number">0</span>; i &lt; n; i += m) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = a[i + j], y = a[i + j + d];</span><br><span class="line">                <span class="keyword">if</span> (rev == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (op == OR)a[i + j + d] = <span class="built_in">add</span>(y, x);</span><br><span class="line">                    <span class="keyword">if</span> (op == AND)a[i + j] = <span class="built_in">add</span>(x, y);</span><br><span class="line">                    <span class="keyword">if</span> (op == XOR)a[i + j] = <span class="built_in">add</span>(x, y), a[i + j + d] = <span class="built_in">sub</span>(x, y);</span><br><span class="line">                    <span class="keyword">if</span> (op == XNOR)a[i + j] = <span class="built_in">sub</span>(y, x), a[i + j + d] = <span class="built_in">add</span>(x, y);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ll inv2 = (mod + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (op == OR)a[i + j + d] = <span class="built_in">sub</span>(y, x);</span><br><span class="line">                    <span class="keyword">if</span> (op == AND)a[i + j] = <span class="built_in">sub</span>(x, y);</span><br><span class="line">                    <span class="keyword">if</span> (op == XOR)a[i + j] = <span class="number">1ll</span> * <span class="built_in">add</span>(x, y) * inv2 % mod, a[i + j + d] = <span class="number">1ll</span> * <span class="built_in">sub</span>(x, y) * inv2 % mod;</span><br><span class="line">                    <span class="keyword">if</span> (op == XNOR)a[i + j] = <span class="number">1ll</span> * <span class="built_in">sub</span>(y, x) * inv2 % mod, a[i + j + d] = <span class="number">1ll</span> * <span class="built_in">add</span>(x, y) * inv2 % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[maxn], B[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> *b, <span class="keyword">int</span> m, <span class="keyword">int</span> *ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bitn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (bitn &lt; (n + m))bitn &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitn; ++i)A[i] = a[i], B[i] = b[i];</span><br><span class="line">    <span class="built_in">fwt</span>(op, A, bitn, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fwt</span>(op, B, bitn, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitn; ++i)ans[i] = <span class="number">1ll</span> * A[i] * B[i] % mod;</span><br><span class="line">    <span class="built_in">fwt</span>(op, ans, bitn, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><h4 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt, dfn[maxn], low[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">&#125; e[maxn * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn], cut[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut_bridge</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> fa, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    vis[cur] = <span class="number">1</span>;</span><br><span class="line">    dfn[cur] = low[cur] = dep;</span><br><span class="line">    <span class="keyword">int</span> children = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[cur]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (x != fa &amp;&amp; vis[x] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[x] &lt; low[cur])low[cur] = dfn[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis[x] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">cut_bridge</span>(x, cur, dep + <span class="number">1</span>);</span><br><span class="line">            children++;</span><br><span class="line">            <span class="keyword">if</span> (low[x] &lt; low[cur])low[cur] = low[x];</span><br><span class="line">            <span class="keyword">if</span> ((fa == <span class="number">-1</span> &amp;&amp; children &gt; <span class="number">1</span>) || (fa != <span class="number">-1</span> &amp;&amp; low[x] &gt;= dfn[cur]))cut[cur] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[cur] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="边双联通分量"><a href="#边双联通分量" class="headerlink" title="边双联通分量"></a>边双联通分量</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[maxn * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> low[maxn], dfn[maxn], vis[maxn], ans[maxn * <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    dfn[u] = low[u] = ++cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[x] == <span class="number">1</span> &amp;&amp; x != fa) &#123;</span><br><span class="line">            <span class="keyword">if</span> (low[u] &gt; dfn[x])low[u] = dfn[x];</span><br><span class="line">            ans[++top] = u;</span><br><span class="line">            ans[++top] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis[x] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(x, u);</span><br><span class="line">            <span class="keyword">if</span> (low[x] &lt; low[u])low[u] = low[x];</span><br><span class="line">            <span class="keyword">if</span> (low[x] &gt; dfn[u]) &#123;</span><br><span class="line">                ans[++top] = u;</span><br><span class="line">                ans[++top] = x;</span><br><span class="line">                ans[++top] = x;</span><br><span class="line">                ans[++top] = u;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[++top] = u;</span><br><span class="line">                ans[++top] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tarjan(i ,-1);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="点双连通分量"><a href="#点双连通分量" class="headerlink" title="点双连通分量"></a>点双连通分量</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[maxn * <span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, top = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], s[maxn], vis[maxn];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; color[maxn];</span><br><span class="line"><span class="keyword">int</span> block[maxn];</span><br><span class="line"><span class="keyword">int</span> block_color = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = v;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bic</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> fa, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    vis[v] = <span class="number">1</span>;</span><br><span class="line">    s[++top] = v;</span><br><span class="line">    block[v] = block_color;</span><br><span class="line">    dfn[v] = low[v] = dep;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[v]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[x] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">bic</span>(x, v, dep + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (low[x] &gt;= dfn[v]) &#123;</span><br><span class="line">                tot++;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    color[s[top]].<span class="built_in">push_back</span>(tot);</span><br><span class="line">                    top--;</span><br><span class="line">                &#125; <span class="keyword">while</span> (s[top + <span class="number">1</span>] != x);</span><br><span class="line">                <span class="keyword">if</span> (low[x] == dfn[v])color[v].<span class="built_in">push_back</span>(tot);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (low[x] &lt;= low[v])low[v] = low[x];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x != fa &amp;&amp; vis[x] == <span class="number">1</span>)low[v] = <span class="built_in">min</span>(low[v], dfn[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[v] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bic(x, -1, 0);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="极大强连通分量"><a href="#极大强连通分量" class="headerlink" title="极大强连通分量"></a>极大强连通分量</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> low[maxn], dfn[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    s[++top] = x;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    dfn[x] = low[x] = ++cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = v[x][i];</span><br><span class="line">        <span class="keyword">if</span> (dfn[u] == <span class="number">0</span>)<span class="built_in">tarjan</span>(u);</span><br><span class="line">        <span class="keyword">if</span> (vis[u] &amp;&amp; low[x] &gt; low[u])low[x] = low[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[top + <span class="number">1</span>] != x) &#123;</span><br><span class="line">            top--;</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>使用堆优化Dijkstra，复杂度 $O(mlogn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, u;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> heap &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; b.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, vi;</span><br><span class="line">&#125; e[maxn * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt, dis[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = y;</span><br><span class="line">    e[cnt].next = head[x];</span><br><span class="line">    e[cnt].vi = z;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> src)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;heap&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    dis[src] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>((heap) &#123;<span class="number">0</span>, src&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        heap uu = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> x = uu.u;</span><br><span class="line">        <span class="keyword">if</span> (vis[x])<span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[x] + e[i].vi) &#123;</span><br><span class="line">                dis[v] = dis[x] + e[i].vi;</span><br><span class="line">                q.<span class="built_in">push</span>((heap&#123;dis[v], v&#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>邻接矩阵存储，复杂度 $O(n^2)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[maxn][maxn], dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> src)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[src] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">-1</span>, m = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[y] &amp;&amp; dis[y] &lt;= m) &#123;</span><br><span class="line">                x = y;</span><br><span class="line">                m = dis[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">        vis[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++y) &#123;</span><br><span class="line">            dis[y] = <span class="built_in">min</span>(dis[y], dis[x] + g[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, vi;</span><br><span class="line">&#125; e[maxm];</span><br><span class="line"><span class="keyword">int</span> head[maxn], dis[maxn], cnt;</span><br><span class="line"><span class="keyword">bool</span> inq[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = y;</span><br><span class="line">    e[cnt].next = head[x];</span><br><span class="line">    e[cnt].vi = z;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> src)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[src] = <span class="number">0</span>;</span><br><span class="line">    inq[src] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(src);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[l]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[l] + e[i].vi &lt; dis[x]) &#123;</span><br><span class="line">                dis[x] = dis[l] + e[i].vi;</span><br><span class="line">                <span class="keyword">if</span> (!inq[x]) &#123;</span><br><span class="line">                    inq[x] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inq[l] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd - Warshall"></a>Floyd - Warshall</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Warshall求传递闭包*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Warshall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                g[i][j] = g[i][j] | (g[i][k] &amp; g[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="次短路"><a href="#次短路" class="headerlink" title="次短路"></a>次短路</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt, n, m, dis[maxn], dis1[maxn];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line">priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, vi;</span><br><span class="line">&#125; e[maxm * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = y;</span><br><span class="line">    e[cnt].next = head[x];</span><br><span class="line">    e[cnt].vi = z;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        <span class="built_in">memset</span>(dis1, <span class="number">63</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis1));</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            <span class="built_in">ins</span>(x, y, z);</span><br><span class="line">            <span class="built_in">ins</span>(y, x, z);</span><br><span class="line">        &#125;</span><br><span class="line">        dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">P</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            P u = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> v = u.second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[v]; i; i = e[i].next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[e[i].to] &gt; u.first + e[i].vi) &#123;</span><br><span class="line">                    dis1[e[i].to] = dis[e[i].to];</span><br><span class="line">                    dis[e[i].to] = u.first + e[i].vi;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">P</span>(dis[e[i].to], e[i].to));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis1[e[i].to] &gt; u.first + e[i].vi &amp;&amp; dis[e[i].to] &lt; u.first + e[i].vi) &#123;</span><br><span class="line">                    dis1[e[i].to] = u.first + e[i].vi;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">P</span>(dis1[e[i].to], e[i].to));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis1[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><h4 id="匹配的相关概念"><a href="#匹配的相关概念" class="headerlink" title="匹配的相关概念"></a>匹配的相关概念</h4><p>记图 $G=(V,E)$。<br>1.匹配：（边集）在G中两两没有公共端点的边集合 $ME$。<br>2.边覆盖：G中的任意顶点都至少是F中某条边的端点的边集合 $ FE$。<br>3.独立集：（点集）在G中两两互不相连的顶点集合 $SV$。<br>4.顶点覆盖：G中的任意边都有至少一个端点属于S的顶点集合 $SV$。</p>
<p>a.对于不存在孤立点的图，|最大匹配|+|最小边覆盖|=|V|。<br>b.|最大独立集|+|最小顶点覆盖|=|V|。<br>c.对于二分图：|最大匹配|=|最小顶点覆盖|。</p>
<h4 id="朴素匹配"><a href="#朴素匹配" class="headerlink" title="朴素匹配"></a>朴素匹配</h4><p>求取最大匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find_path</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i] &amp;&amp; g[x][i]) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p[i] || <span class="built_in">find_path</span>(p[i])) &#123;</span><br><span class="line">                p[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if (find_path(i))tot++;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><p>邻接矩阵存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> from[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g[x][i] &amp;&amp; vis[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (from[i] == <span class="number">-1</span> || <span class="built_in">match</span>(from[i])) &#123;</span><br><span class="line">                from[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(from, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(from));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">match</span>(i))</span><br><span class="line">            ++tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="lca"><a href="#lca" class="headerlink" title="lca"></a>lca</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxh = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, tot, head[maxn], f[maxn][<span class="number">25</span>], dep[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next;</span><br><span class="line">&#125; e[<span class="number">2</span> * maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[++tot].to = y, e[tot].next = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[x]; i++)</span><br><span class="line">        f[x][i] = f[f[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxh; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (dep[f[y][i]] &gt;= dep[x]) y = f[y][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxh; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生成树Kruskal"><a href="#生成树Kruskal" class="headerlink" title="生成树Kruskal"></a>生成树Kruskal</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r[maxn], p[maxn], u[maxn], v[maxn], w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> w[i] &lt; w[j]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[i], &amp;u[i], &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)p[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)r[i] = i;</span><br><span class="line">    <span class="built_in">sort</span>(r + <span class="number">1</span>, r + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> e = r[i];</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(v[e]);</span><br><span class="line">        <span class="keyword">int</span> y = <span class="built_in">find</span>(u[e]);</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            p[x] = y;</span><br><span class="line">            tot++;</span><br><span class="line">            sum += w[e];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><h4 id="最大流-Ford-Fulkerson实现"><a href="#最大流-Ford-Fulkerson实现" class="headerlink" title="最大流 Ford-Fulkerson实现"></a>最大流 Ford-Fulkerson实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, cap, rev;</span><br><span class="line">&#125; e[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">310</span>], n, m, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = t;</span><br><span class="line">    e[cnt].next = head[s];</span><br><span class="line">    head[s] = cnt;</span><br><span class="line">    e[cnt].cap = c;</span><br><span class="line">    e[cnt].rev = cnt + <span class="number">1</span>;</span><br><span class="line">    e[++cnt].to = s;</span><br><span class="line">    e[cnt].next = head[t];</span><br><span class="line">    head[t] = cnt;</span><br><span class="line">    e[cnt].cap = <span class="number">0</span>;</span><br><span class="line">    e[cnt].rev = cnt - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == t)<span class="keyword">return</span> f;</span><br><span class="line">    vis[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[v]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; e[i].cap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = <span class="built_in">dfs</span>(e[i].to, t, <span class="built_in">min</span>(f, e[i].cap));</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e[i].cap -= d;</span><br><span class="line">                e[e[i].rev].cap += d;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="keyword">int</span> f = <span class="built_in">dfs</span>(s, t, <span class="number">1e9</span>);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>)<span class="keyword">return</span> flow;</span><br><span class="line">        flow += f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大流Dinic实现"><a href="#最大流Dinic实现" class="headerlink" title="最大流Dinic实现"></a>最大流Dinic实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, cap, rev;</span><br><span class="line">&#125; e[maxm];</span><br><span class="line"><span class="keyword">int</span> n, m, cnt = <span class="number">0</span>, head[maxn], dis[maxn], iter[maxn];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = y;</span><br><span class="line">    e[cnt].next = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">    e[cnt].cap = z;</span><br><span class="line">    e[cnt].rev = cnt + <span class="number">1</span>;</span><br><span class="line">    e[++cnt].to = x;</span><br><span class="line">    e[cnt].next = head[y];</span><br><span class="line">    head[y] = cnt;</span><br><span class="line">    e[cnt].cap = <span class="number">0</span>;</span><br><span class="line">    e[cnt].rev = cnt - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[i].cap &amp;&amp; dis[e[i].to] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(e[i].to);</span><br><span class="line">                dis[e[i].to] = dis[u] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == t)<span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (iter[v] ? iter[v] : head[v]); i; i = e[i].next, iter[v] = i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i].cap &amp;&amp; dis[v] &lt; dis[e[i].to]) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = <span class="built_in">dfs</span>(e[i].to, t, <span class="built_in">min</span>(f, e[i].cap));</span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                e[i].cap -= d;</span><br><span class="line">                e[e[i].rev].cap += d;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">bfs</span>(s);</span><br><span class="line">        <span class="keyword">if</span> (dis[t] &lt; <span class="number">0</span>)<span class="keyword">return</span> flow;</span><br><span class="line">        <span class="built_in">memset</span>(iter, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(iter));</span><br><span class="line">        <span class="keyword">int</span> f;</span><br><span class="line">        <span class="keyword">while</span> ((f = <span class="built_in">dfs</span>(s, t, <span class="number">1e9</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">            flow += f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h4><p>SPFA实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> cnt, head[maxn], dis[maxn], prevv[maxn], preve[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, cap, cost, rev;</span><br><span class="line">&#125; e[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = y;</span><br><span class="line">    e[cnt].next = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">    e[cnt].cap = z;</span><br><span class="line">    e[cnt].rev = cnt + <span class="number">1</span>;</span><br><span class="line">    e[cnt].cost = c;</span><br><span class="line">    e[++cnt].to = x;</span><br><span class="line">    e[cnt].next = head[y];</span><br><span class="line">    head[y] = cnt;</span><br><span class="line">    e[cnt].cap = <span class="number">0</span>;</span><br><span class="line">    e[cnt].rev = cnt - <span class="number">1</span>;</span><br><span class="line">    e[cnt].cost = -c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_cost_flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (f &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s);</span><br><span class="line">        dis[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; <span class="number">1e8</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[v]; i; i = e[i].next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e[i].cap &gt; <span class="number">0</span> &amp;&amp; dis[e[i].to] &gt; dis[v] + e[i].cost) &#123;</span><br><span class="line">                    dis[e[i].to] = dis[v] + e[i].cost;</span><br><span class="line">                    prevv[e[i].to] = v;</span><br><span class="line">                    preve[e[i].to] = i;</span><br><span class="line">                    q.<span class="built_in">push</span>(e[i].to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dis[t] &gt; <span class="number">1e8</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> d = f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i != s; i = prevv[i]) &#123;</span><br><span class="line">            d = <span class="built_in">min</span>(d, e[preve[i]].cap);</span><br><span class="line">        &#125;</span><br><span class="line">        f -= d;</span><br><span class="line">        ans += d * dis[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i != s; i = prevv[i]) &#123;</span><br><span class="line">            e[preve[i]].cap -= d;</span><br><span class="line">            e[e[preve[i]].rev].cap += d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h4 id="普通树状数组"><a href="#普通树状数组" class="headerlink" title="普通树状数组"></a>普通树状数组</h4><p> 仅支持单点修改区间查询。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lb</span>(i)) &#123;</span><br><span class="line">        tot += tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lb</span>(i)) &#123;</span><br><span class="line">        tree[i] += num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="普通二维树状数组"><a href="#普通二维树状数组" class="headerlink" title="普通二维树状数组"></a>普通二维树状数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> tree[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lb</span>(i)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j; j -= <span class="built_in">lb</span>(j))</span><br><span class="line">            tot += tree[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lb</span>(i)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += <span class="built_in">lb</span>(j)) &#123;</span><br><span class="line">            tree[i][j] += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树状数组维护区间最大、最小值"><a href="#树状数组维护区间最大、最小值" class="headerlink" title="树状数组维护区间最大、最小值"></a>树状数组维护区间最大、最小值</h4><p>维护区间[1,x]的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[maxn], n, r[maxn], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= <span class="built_in">lb</span>(x))</span><br><span class="line">        tot = <span class="built_in">max</span>(tot, c[x]);</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lb</span>(x)) &#123;</span><br><span class="line">        c[x] = <span class="built_in">max</span>(c[x], v);</span><br><span class="line">        <span class="keyword">int</span> t = x - <span class="built_in">lb</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = x - <span class="number">1</span>; y &amp;&amp; y - <span class="built_in">lb</span>(y) &gt;= t; y -= <span class="built_in">lb</span>(y))</span><br><span class="line">            c[x] = <span class="built_in">max</span>(c[x], c[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="维护区间最值，区间修改"><a href="#维护区间最值，区间修改" class="headerlink" title="维护区间最值，区间修改"></a>维护区间最值，区间修改</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    ll sum, add, maxm, minm;</span><br><span class="line">&#125; c[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">ll a[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    c[id].left = l;</span><br><span class="line">    c[id].right = r;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        c[id].maxm = c[id].minm = c[id].sum = a[l];</span><br><span class="line">        c[id].add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(id &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    c[id].maxm = <span class="built_in">max</span>(c[id &lt;&lt; <span class="number">1</span>].maxm, c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxm);</span><br><span class="line">    c[id].minm = <span class="built_in">min</span>(c[id &lt;&lt; <span class="number">1</span>].minm, c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].minm);</span><br><span class="line">    c[id].sum = c[id &lt;&lt; <span class="number">1</span>].sum + c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    c[id &lt;&lt; <span class="number">1</span>].sum += (c[id &lt;&lt; <span class="number">1</span>].right - c[id &lt;&lt; <span class="number">1</span>].left + <span class="number">1</span>) * c[id].add;</span><br><span class="line">    c[id &lt;&lt; <span class="number">1</span>].minm += c[id].add;</span><br><span class="line">    c[id &lt;&lt; <span class="number">1</span>].maxm += c[id].add;</span><br><span class="line">    c[id &lt;&lt; <span class="number">1</span>].add += c[id].add;</span><br><span class="line">    c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += (c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].right - c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].left + <span class="number">1</span>) * c[id].add;</span><br><span class="line">    c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].minm += c[id].add;</span><br><span class="line">    c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxm += c[id].add;</span><br><span class="line">    c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].add += c[id].add;</span><br><span class="line">    c[id].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> pos, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c[id].left == c[id].right)c[id].sum = c[id].maxm = c[id].minm = v;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (c[id].left + c[id].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid)<span class="built_in">update</span>(id &lt;&lt; <span class="number">1</span>, pos, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, pos, v);</span><br><span class="line">        c[id].sum = c[id &lt;&lt; <span class="number">1</span>].sum + c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">        c[id].maxm = <span class="built_in">max</span>(c[id &lt;&lt; <span class="number">1</span>].maxm, c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxm);</span><br><span class="line">        c[id].minm = <span class="built_in">min</span>(c[id &lt;&lt; <span class="number">1</span>].minm, c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].minm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c[id].left == l &amp;&amp; c[id].right == r)<span class="keyword">return</span> c[id].maxm;</span><br><span class="line">    <span class="keyword">int</span> mid = (c[id].left + c[id].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (c[id].add)<span class="built_in">pushdown</span>(id);</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)<span class="keyword">return</span> <span class="built_in">query_max</span>(id &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid)<span class="keyword">return</span> <span class="built_in">query_max</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query_max</span>(id &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">query_max</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c[id].left == l &amp;&amp; c[id].right == r)<span class="keyword">return</span> c[id].minm;</span><br><span class="line">    <span class="keyword">int</span> mid = (c[id].left + c[id].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (c[id].add)<span class="built_in">pushdown</span>(id);</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid)<span class="keyword">return</span> <span class="built_in">query_min</span>(id &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid)<span class="keyword">return</span> <span class="built_in">query_min</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query_min</span>(id &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">query_min</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c[id].left &gt; r || c[id].right &lt; l)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (c[id].left &gt;= l &amp;&amp; c[id].right &lt;= r) &#123;</span><br><span class="line">        c[id].add += v;</span><br><span class="line">        c[id].sum += (c[id].right - c[id].left + <span class="number">1</span>) * v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c[id].add)<span class="built_in">pushdown</span>(id);</span><br><span class="line">    <span class="built_in">update</span>(id &lt;&lt; <span class="number">1</span>, l, r, v);</span><br><span class="line">    <span class="built_in">update</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, v);</span><br><span class="line">    c[id].sum = c[id &lt;&lt; <span class="number">1</span>].sum + c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">query_sum</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; c[id].left || l &gt; c[id].right)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c[id].left &gt;= l &amp;&amp; c[id].right &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> c[id].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c[id].add)<span class="built_in">pushdown</span>(id);</span><br><span class="line">    ll ans = <span class="built_in">query_sum</span>(id &lt;&lt; <span class="number">1</span>, l, r) + <span class="built_in">query_sum</span>(id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    c[id].sum = c[id &lt;&lt; <span class="number">1</span>].sum + c[id &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h4 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">1e6</span> + <span class="number">10</span>) * <span class="number">51</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ls[maxn], rs[maxn], cnt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right, mmin;</span><br><span class="line">&#125; c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    c[id].left = l;</span><br><span class="line">    c[id].right = r;</span><br><span class="line">    c[id].mmin = inf;</span><br><span class="line">    ls[id] = rs[id] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> pos, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c[id].left == c[id].right)c[id].mmin = <span class="built_in">min</span>(c[id].mmin, v);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (c[id].left + c[id].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ls[id] == <span class="number">0</span>) &#123;</span><br><span class="line">                ls[id] = cnt;</span><br><span class="line">                <span class="built_in">build</span>(cnt, c[id].left, mid);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">update</span>(ls[id], pos, v);</span><br><span class="line">            c[id].mmin = <span class="built_in">min</span>(c[id].mmin, c[ls[id]].mmin);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs[id] == <span class="number">0</span>) &#123;</span><br><span class="line">                rs[id] = cnt;</span><br><span class="line">                <span class="built_in">build</span>(cnt, mid + <span class="number">1</span>, c[id].right);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">update</span>(rs[id], pos, v);</span><br><span class="line">            c[id].mmin = <span class="built_in">min</span>(c[id].mmin, c[rs[id]].mmin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ck)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c[id].left == l &amp;&amp; c[id].right == r)<span class="keyword">return</span> (ck &gt;= c[id].mmin);</span><br><span class="line">    <span class="keyword">if</span> (c[id].mmin &gt; ck)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (c[id].left + c[id].right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ls[id] != <span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">query_min</span>(ls[id], l, r, ck);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs[id] != <span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">query_min</span>(rs[id], l, r, ck);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ls[id] != <span class="number">0</span> &amp;&amp; <span class="built_in">query_min</span>(ls[id], l, mid, ck))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rs[id] != <span class="number">0</span> &amp;&amp; <span class="built_in">query_min</span>(rs[id], mid + <span class="number">1</span>, r, ck))<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="常见线性模型"><a href="#常见线性模型" class="headerlink" title="常见线性模型"></a>常见线性模型</h3><h4 id="LIS-O-nlogn"><a href="#LIS-O-nlogn" class="headerlink" title="LIS(O(nlogn))"></a>LIS(O(nlogn))</h4><p> 采用树状数组优化。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c[maxn], n, r[maxn], a[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= <span class="built_in">lb</span>(x))</span><br><span class="line">        tot = <span class="built_in">max</span>(tot, c[x]);</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lb</span>(x)) &#123;</span><br><span class="line">        c[x] = <span class="built_in">max</span>(c[x], v);</span><br><span class="line"><span class="comment">//        int t = x - lb(x);</span></span><br><span class="line"><span class="comment">//        for (int y = x - 1; y &amp;&amp; y - lb(y) &gt;= t; y -= lb(y))</span></span><br><span class="line"><span class="comment">//            c[x] = max(c[x], c[y]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i] == a[j] ? i &lt; j : a[i] &lt; a[j];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    <span class="keyword">int</span> _;</span><br><span class="line">    cin &gt;&gt; _;</span><br><span class="line">    <span class="keyword">while</span> (_--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            r[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(r + <span class="number">1</span>, r + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = r[j];</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in">query</span>(i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">update</span>(i, tmp);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h4><p>复杂度O(nlogn)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">define ll <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">define ull <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line"><span class="function">define __ <span class="title">ios::sync_with_stdio</span><span class="params">(<span class="number">0</span>)</span></span>;cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn], b[maxn], c[maxn];</span><br><span class="line"><span class="keyword">int</span> mp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= <span class="built_in">lb</span>(x))</span><br><span class="line">        tot = <span class="built_in">max</span>(tot, c[x]);</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lb</span>(x)) &#123;</span><br><span class="line">        c[x] = <span class="built_in">max</span>(c[x], v);</span><br><span class="line"><span class="comment">//        int t = x - lb(x);</span></span><br><span class="line"><span class="comment">//        for (int y = x - 1; y &amp;&amp; y - lb(y) &gt;= t; y -= lb(y))</span></span><br><span class="line"><span class="comment">//            c[x] = max(c[x], c[y]);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        mp[b[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) b[i] = mp[a[i]];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">query</span>(b[i] - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">update</span>(b[i], tmp);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LCIS"><a href="#LCIS" class="headerlink" title="LCIS"></a>LCIS</h4><p>复杂度O(n*m)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            f[i][j] = a[i] == b[j] ? tot + <span class="number">1</span> : f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (b[j] &lt; a[i])tot = <span class="built_in">max</span>(tot, f[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)ans = <span class="built_in">max</span>(ans, f[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="石子合并问题"><a href="#石子合并问题" class="headerlink" title="石子合并问题"></a>石子合并问题</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">define ll <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">define ull <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line"><span class="function">define __ <span class="title">ios::sync_with_stdio</span><span class="params">(<span class="number">0</span>)</span></span>;cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">201</span>][<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">        sum[i + n] = sum[i + n - <span class="number">1</span>] + a[i + n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + k &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = i + k;</span><br><span class="line">            f[i][r] = inf;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; r; j++)f[i][r] = <span class="built_in">min</span>(f[i][r], sum[r] - sum[i - <span class="number">1</span>] + f[i][j] + f[j + <span class="number">1</span>][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tot = <span class="built_in">min</span>(tot, f[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; tot &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + k &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = i + k;</span><br><span class="line">            f[i][r] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; r; j++)f[i][r] = <span class="built_in">max</span>(f[i][r], sum[r] - sum[i - <span class="number">1</span>] + f[i][j] + f[j + <span class="number">1</span>][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)tot = <span class="built_in">max</span>(tot, f[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; tot;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树型dp"><a href="#树型dp" class="headerlink" title="树型dp"></a>树型dp</h3><p>森林转二叉树：<br>题意：给你n门课程，每门课有其先修课和学分。求选m门课程的最大学分。（森林转二叉树）</p>
<p>树形dp。关键是存树的方式。</p>
<p>在森林上找多个包含树根的连通块，使所有点的权值最大。</p>
<p>用二叉树存储，定义两个数组head和next，其中head[i]表示节点i的第一个儿子节点，next[i]表示节点i的兄弟节点。</p>
<p>若以知一个节点的父亲，则插入该节点的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (head[fa] == <span class="number">0</span>)head[fa] = i;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> t = head[fa];</span><br><span class="line">    <span class="keyword">while</span> (next[t] != <span class="number">0</span>)t = next[t];</span><br><span class="line">    next[t] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp方程：</p>
<p>$f[c][s]$ 表示在二叉树中以c为根的子树中取s个节点的最大权值，其中这s个节点均联通。</p>
<p>$f[c][s] = a[c] + max(f[head[c]][i], f[next[c]][s - 1 - i]);$</p>
<p>由于二叉树中节点c的右节点实际上与c是兄弟关系，故$f[c][s]$的值可以不包含节点c，故还应保证</p>
<p>$f[c][s] = max(f[c][s], f[next[c]][s]);$</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">define ll <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">define ull <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line"><span class="function">define __ <span class="title">ios::sync_with_stdio</span><span class="params">(<span class="number">0</span>)</span></span>;cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">1001</span>], nxt[<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[c][s] != <span class="number">0</span>)<span class="keyword">return</span> f[c][s];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; i++)f[c][s] = <span class="built_in">max</span>(f[c][s], a[c] + <span class="built_in">dp</span>(head[c], i) + <span class="built_in">dp</span>(nxt[c], s - <span class="number">1</span> - i));</span><br><span class="line">    f[c][s] = <span class="built_in">max</span>(f[c][s], <span class="built_in">dp</span>(nxt[c], s));</span><br><span class="line">    <span class="keyword">return</span> f[c][s];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa;</span><br><span class="line">        cin &gt;&gt; fa;</span><br><span class="line">        <span class="keyword">if</span> (head[fa] == <span class="number">0</span>)head[fa] = i;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = head[fa];</span><br><span class="line">            <span class="keyword">while</span> (nxt[t] != <span class="number">0</span>)t = nxt[t];</span><br><span class="line">            nxt[t] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(head[<span class="number">0</span>], m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p> 手动实现版：</p>
<p>例题大意：给出N个矩形和他们的高和宽 现在把他们宽放在x轴上对齐，请问现在最大矩形面积。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right, height;</span><br><span class="line">&#125; s[maxn], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, w, h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; w &gt;&gt; h;</span><br><span class="line">            a[i].height = h;</span><br><span class="line">            a[i].left = l;</span><br><span class="line">            l += w;</span><br><span class="line">            a[i].right = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; s[top].height &gt; a[i].height) &#123;</span><br><span class="line">                Data p = s[top--];</span><br><span class="line">                <span class="keyword">if</span> (top == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, p.height * (a[i].left));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, p.height * (a[i].left - s[top].right));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Data x;</span><br><span class="line">            x.left = a[i].left;</span><br><span class="line">            x.right = a[i].right;</span><br><span class="line">            x.height = a[i].height;</span><br><span class="line">            s[++top] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (top) &#123;</span><br><span class="line">            Data p = s[top--];</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, p.height * (a[n].right));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, p.height * (a[n].right - s[top].right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>STL写法：<br>例题：给出直方图上n个矩形的高度，求最大面积。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;pair&lt;ll, ll&gt; &gt; s;</span><br><span class="line">ll n, a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>().first &gt; a[i]) &#123;</span><br><span class="line">                pair&lt;ll, ll&gt; p = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, p.first * (i - <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, (i - <span class="number">1</span> - s.<span class="built_in">top</span>().second) * p.first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(a[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            pair&lt;ll, ll&gt; p = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, n * p.first);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (n - s.<span class="built_in">top</span>().second) * p.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不使用栈，直接用数组记录。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2001</span>][<span class="number">2001</span>], h[<span class="number">2001</span>][<span class="number">2001</span>];</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">2002</span>][<span class="number">2001</span>], r[<span class="number">2002</span>][<span class="number">2002</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">            <span class="keyword">if</span> (a[i][j]) &#123;</span><br><span class="line">                h[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (h[i - <span class="number">1</span>][j])h[i][j] += h[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> h[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[i][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = j - <span class="number">1</span>;</span><br><span class="line">                l[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (t &gt;= <span class="number">1</span> &amp;&amp; h[i][j] &lt;= h[i][t]) &#123;</span><br><span class="line">                    l[i][j] += l[i][t];</span><br><span class="line">                    t -= l[i][t];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[i][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = j + <span class="number">1</span>;</span><br><span class="line">                r[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (t &lt;= m &amp;&amp; h[i][j] &lt;= h[i][t]) &#123;</span><br><span class="line">                    r[i][j] += r[i][t];</span><br><span class="line">                    t += r[i][t];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            tot = <span class="built_in">max</span>(tot, (l[i][j] + r[i][j] - <span class="number">1</span>) * h[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>手动实现版：</p>
<p>r - 2 <em> sum[r] - ((l - 1) - 2 </em> sum[l-1]) + x ，维护对于每个r，只需找出最小的((l - 1) - 2 * sum[l - 1])即可。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + c[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    q[++r] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[r] - sum[q[r]] * <span class="number">2</span> &gt; i - sum[i] * <span class="number">2</span>)</span><br><span class="line">            --r;</span><br><span class="line">        q[++r] = i;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; sum[q[r]] - sum[q[l]] &gt; x)</span><br><span class="line">            ++l;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, q[r] - <span class="number">2</span> * sum[q[r]] - (q[l] - <span class="number">2</span> * sum[q[l]]) + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>STL实现版：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll sum[maxn], b[maxn];</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dp</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; sum[q.<span class="built_in">front</span>()] &gt; sum[i])</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        q.<span class="built_in">push_front</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; i - len &gt; q.<span class="built_in">back</span>())</span><br><span class="line">            q.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>)ans = <span class="built_in">max</span>(ans, sum[i] - sum[q.<span class="built_in">back</span>()]);</span><br><span class="line">        <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><p>Windy数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">ll f[<span class="number">101</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dp</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a[len]; ++i) &#123;</span><br><span class="line">        ans += f[len][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(j - a[i + <span class="number">1</span>]) &gt;= <span class="number">2</span>)ans += f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i] - a[i + <span class="number">1</span>]) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            ans--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            ans += f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t) &#123;</span><br><span class="line">        a[++pos] = (<span class="keyword">int</span>) (t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">        f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(j - k) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>(b) - <span class="built_in">solve</span>(a - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四边形不等式优化"><a href="#四边形不等式优化" class="headerlink" title="四边形不等式优化"></a>四边形不等式优化</h3><p>$f[i][j]=m i n\{ f[i][k] + f[k+1][j] \}+w[i][j]$</p>
<ul>
<li>若$w[a][c]+w[b][d]\leq w[b][c]+w[a][d]\ (a&lt;b&lt;c&lt;d)$则称w满足四边形不等式</li>
<li>w满足四边形不等式，当且仅当$w[i][j]+w[i+1][j+1]\leq w[i+1][j]+w[i][j+1]$</li>
<li>若$w[a][b]&lt;=w[a’][b’]\ ([a,\ b]\subset [a’,\ b’])$则称w关于区间包含关系单调</li>
<li>如果w满足四边形不等式且关于区间包含关系单调，则f也满足四边形不等式</li>
<li>如果f满足四边形不等式，则决策点$p[i][j-1]\leq p[i][j]\leq p[i+1][j]$，此时若把p看作一个矩阵则p在每一行和每一列上上单调不降</li>
</ul>
<p>此时k的枚举由$[i,\ j]$变为了$[p[i][j-1],\ p[i+1][j]]$。只要将p矩阵打印出来观察每行每列是否单调即可，如果单调说明方程可以四边形优化。 </p>
<h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><h3 id="星期计算"><a href="#星期计算" class="headerlink" title="星期计算"></a>星期计算</h3><p>只适用于1582年之后的日期。</p>
<p>计算星期几的公式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Day</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span> || m == <span class="number">2</span>) &#123;</span><br><span class="line">        m += <span class="number">12</span>;</span><br><span class="line">        --y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (d + <span class="number">2</span> * m + <span class="number">3</span> * (m + <span class="number">1</span>) / <span class="number">5</span> + y + y / <span class="number">4</span> - y / <span class="number">100</span> + y / <span class="number">400</span>) % <span class="number">7</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求得的结果1~7分别表示星期一到星期日。</p>
<h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>树状数组写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, r[maxn];</span><br><span class="line">ll a[maxn], c[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lb</span>(i))tot += c[i];</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll num, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lb</span>(i))</span><br><span class="line">        c[i] += num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i == j ? i &lt; j : a[i] &lt; a[j]; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(r + <span class="number">1</span>, r + <span class="number">1</span> + n, cmp);</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = r[i];</span><br><span class="line">        tot += <span class="built_in">read</span>(n) - <span class="built_in">read</span>(x);</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">1</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; tot &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归并排序写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">inversed_pair</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    sum += <span class="built_in">inversed_pair</span>(a, mid);</span><br><span class="line">    sum += <span class="built_in">inversed_pair</span>(a + mid, n - mid);</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="built_in">memcpy</span>(b, a, n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = mid, i = <span class="number">0</span>; i1 &lt; mid || i2 &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i2 == n) &#123;</span><br><span class="line">            a[i] = b[i1];</span><br><span class="line">            ++i1;</span><br><span class="line">            sum += i2 - mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i1 == mid) &#123;</span><br><span class="line">            a[i] = b[i2];</span><br><span class="line">            ++i2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b[i1] &lt; b[i2]) &#123;</span><br><span class="line">            a[i] = b[i1];</span><br><span class="line">            ++i1;</span><br><span class="line">            sum += i2 - mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a[i] = b[i2];</span><br><span class="line">            ++i2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l + eps &lt; r) &#123;</span><br><span class="line">    <span class="keyword">double</span> lm = l + (r - l) / <span class="number">3.0</span>, rm = l + <span class="number">2.0</span> * (r - l) / <span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dis</span>(lm) &gt; <span class="built_in">dis</span>(rm))</span><br><span class="line">        r = rm;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l = lm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="母函数"><a href="#母函数" class="headerlink" title="母函数"></a>母函数</h3><p>有n个重量为1g的砝码，n/2个重量为2g的砝码，…，1个重量为ng的砝码，问称取ng的物品有多少种放砝码的方法。</p>
<p>$(1 + x + x^2 + x^3 + … + x^n) <em> (1 + x^2 + x^4 + … + x^n) </em> … * (1 + x^n)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c1[maxn], c2[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            c1[i] = <span class="number">1</span>;</span><br><span class="line">            c2[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k + j &lt;= n; k += i) &#123;</span><br><span class="line">                    c2[j + k] += c1[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                c1[j] = c2[j];</span><br><span class="line">                c2[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; c1[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h2><h3 id="盒子放小球问题"><a href="#盒子放小球问题" class="headerlink" title="盒子放小球问题"></a>盒子放小球问题</h3><p>$n$个小球，$m$个盒子。</p>
<h4 id="n个小球有区别，m个盒子有区别"><a href="#n个小球有区别，m个盒子有区别" class="headerlink" title="n个小球有区别，m个盒子有区别"></a>n个小球有区别，m个盒子有区别</h4><p>(1)允许空盒：每个球放到任意盒子里，总方案数$m^n$。</p>
<p>(2)不允许空盒：需满足$n \geq m\geq 1$ ，$m&gt;n$时无解。其方案数及时看成m个盒子相同时的方案数，再乘以$m!$。答案即是$S(n,m)*m!$。S代表第二类斯特林数。</p>
<h4 id="n个小球有区别，m个盒子无区别"><a href="#n个小球有区别，m个盒子无区别" class="headerlink" title="n个小球有区别，m个盒子无区别"></a>n个小球有区别，m个盒子无区别</h4><p>(1)允许空盒：假设放了k个盒，$m\geq k\geq 1$。那么答案就 $\sum_{k=1}^{m}S(n,k)$。</p>
<p>(2)不允许有空盒：$S(n,m)$。</p>
<h4 id="n个小球无区别，m个盒子有区别"><a href="#n个小球无区别，m个盒子有区别" class="headerlink" title="n个小球无区别，m个盒子有区别"></a>n个小球无区别，m个盒子有区别</h4><p>(1)允许空盒：$n\geq m\geq 1$。“隔板法”。假设不允许有空盒，每一个盒里都先放一个小球，这样小球共有$n+m$个，然后插板，插板的方案数为 $C^{n-1}_{n+m-1}$ 。</p>
<p>(2)不允许空盒： $n\geq m\geq 1$ 。“隔板法”。方案数 $C^{m-1}_{n-1}$ 。</p>
<h4 id="n个小球无区别，m个盒子无区别"><a href="#n个小球无区别，m个盒子无区别" class="headerlink" title="n个小球无区别，m个盒子无区别"></a>n个小球无区别，m个盒子无区别</h4><p>(1) 允许空盒：划分数问题。<br>$dp[i][j]$表示i个球，j个盒子的方案数。转移方程为</p>
<p>$dp[i][j]=dp[i-j][j]+dp[i][j-1] (i\geq j)$</p>
<p>$dp[i][j]=dp[i][j-1] (i&lt; j)$</p>
<p>如果$n&lt;m$，答案为$dp[n][n]$，否则为 $dp[n][m]$。</p>
<p>(2)不允许空盒：<br>$n\geq m\geq 1$。转成上情况的$n-m$个小球，$m$个盒子。</p>
<h3 id="计数原理与计数公式"><a href="#计数原理与计数公式" class="headerlink" title="计数原理与计数公式"></a>计数原理与计数公式</h3><h4 id="可重复的排列与组合"><a href="#可重复的排列与组合" class="headerlink" title="可重复的排列与组合"></a>可重复的排列与组合</h4><h5 id="可重复的排列"><a href="#可重复的排列" class="headerlink" title="可重复的排列"></a>可重复的排列</h5><p>从n个不同元素中取m个元素（同一元素可以重复取出），按照一定的顺序排成一列。排列的个数为 $n^m$。</p>
<h5 id="可重复的组合"><a href="#可重复的组合" class="headerlink" title="可重复的组合"></a>可重复的组合</h5><p>从n个不同元素中取m个元素（同一元素可以重复取出），并成一组。组合的个数为 $C^{m}_{n+m-1}$。</p>
<p>【证明】</p>
<p>$1,2,…,n$表示n个不同元素。从中取m个可以表示成：</p>
<p>$\{i_1,i_2,…,i_m\} (1\leq i_1\leq i_2 \leq … \leq i_m \leq n)$</p>
<p>令$j_k = i_k + (k-1)$，即：</p>
<p>$\begin{aligned}j_1 &amp;= i_1\\<br>j_2 &amp;= i_2+ 1\\<br>j_3 &amp;= i_3 + 2\\<br>…\\<br>j_m &amp;=i_m+(m-1)<br>\end{aligned}$</p>
<p>可以得到组合</p>
<p>$\{j_1,j_2,…,j_m\} (1\leq j_1&lt; j_2 &lt; … &lt;j_m \leq n-m+1)$</p>
<p>这样就相当于在$n+m-1$个元素中取$m$个不相同的元素，作为一组。</p>
<p>因此即是 $C_{n+m-1}^{m}$。</p>
<h5 id="不全相异元素的全排列"><a href="#不全相异元素的全排列" class="headerlink" title="不全相异元素的全排列"></a>不全相异元素的全排列</h5><p>n个元素中，分别有$n_1,n_2,…,n_k$个元素相同，且$n_1+n_2+…+n_k=n$，则称这n个元素的全排列为不全相异元素的全排列，个数为 $\frac{n!}{n_1!n_2!…n_k!}$</p>
<h5 id="多组组合"><a href="#多组组合" class="headerlink" title="多组组合"></a>多组组合</h5><p>n个相异的元素分为$k(k\leq n)$个按照<strong>一定顺序</strong>排列的组，其中第$i$组有$n_i$个元素 $(i=1,2,…,k)(n_1+n_2+…+n_k=n)$。<br>不同的分组方法为 $\frac{n!}{n_1!n_2!…n_k!}$</p>
<p>【例】</p>
<p>从 $n(n\geq 6)$ 个选手中选3对选手参加双打，问共有多少种选法。</p>
<p>答案为（注意不考虑<strong>组的顺序</strong>） <script type="math/tex">\frac{C_{n}^{6}}{3!}*{\frac{6!}{2!*2!*2!}}</script></p>
<h4 id="相异元素的圆排列和项链数"><a href="#相异元素的圆排列和项链数" class="headerlink" title="相异元素的圆排列和项链数"></a>相异元素的圆排列和项链数</h4><h5 id="圆排列"><a href="#圆排列" class="headerlink" title="圆排列"></a>圆排列</h5><p>n个元素不分首尾排成一圈，成为n个相异元素的圆排列。排列的种数为$(n-1)!$。</p>
<h5 id="项链数"><a href="#项链数" class="headerlink" title="项链数"></a>项链数</h5><p>将n粒不相同的珠子，穿成一副项链，得到的不同的项链数。<br>由于项链顺时针和逆时针都是相同的，所以个数即是圆排列的一半。</p>
<p>$\left\{<br>\begin{aligned}<br>&amp;1,n = 1或n=2\\<br>&amp;\frac{1}{2}*(n-1)!,n\geq3<br>\end{aligned}<br>\right.$</p>
<h4 id="错排问题"><a href="#错排问题" class="headerlink" title="错排问题"></a>错排问题</h4><p>错排递推式。</p>
<p>$D(n)$代表$n$个数的错排公式，则<br>$D(n) = (n-1)*[D(n-1)+D(n-2)]$</p>
<p>错排公式</p>
<p>$D(n) = n!(1-\frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+…+\frac{(-1)^n}{n!})$</p>
<h3 id="组合数常用公式"><a href="#组合数常用公式" class="headerlink" title="组合数常用公式"></a>组合数常用公式</h3><script type="math/tex; mode=display">\begin{aligned} &C_{n}^{2} = \frac{n*(n-1)}{2} \\
& C_{n}^{3}=\frac{n*(n-1)(n-2)}{6} \\
& C_{n}^{m}=C_{n-1}^{m-1}+C_{n-1}^{m} \\
& m*C_{n}^{m} = n*C_{n-1}^{m-1} \\
& C_n^0+C_n^1+...+C_n^n =2^n\\
& 1C_n^1+2C_n^2+...+nC_n^n=n2^{n-1}\\
& 1^2C_n^1+2^2C_n^2+...+n^2C_n^n=n(n+1)2^{n-2}\\
& \frac{C_n^1}{1} - \frac{C_n^2}{2} + \frac{C_n^3}{3}+...+(-1)^{n-1} \frac{C_n^n}{n}=1+ \frac{1}{2}+ \frac{1}{3}+...+ \frac{1}{n}\\
& (C_n^0)^2+(C_n^1)^2+(C_n^2)^2+...+(C_n^n)^2=C_{2n}^n \end{aligned}</script><p>范德蒙恒等式:</p>
<script type="math/tex; mode=display">\sum_{i=0}^{k} {C_n^i C_m^{k-i}}= C_{n+m}^k</script><p>经验式<br>(link<br>  [<a href="https://www.cnblogs.com/qrsikno/p/10170523.html">https://www.cnblogs.com/qrsikno/p/10170523.html</a>]<br>  (<a href="https://www.cnblogs.com/qrsikno/p/10170523.html">https://www.cnblogs.com/qrsikno/p/10170523.html</a>)<br>  ):</p>
<script type="math/tex; mode=display">\begin{aligned} &\sum_{i=0}^{n}C_n^i*r^i=(r+1)^n（广义二项式定理）\\
&\sum_{i=0}^{n}i*C_n^i=n*2^{n-1}\\&\\
&\sum_{i=0}^{n}C_i^k=C_{n+1}^{k+1}\\&\\
&\sum_{i=0}^{k}C_{n+i}^i=C_{n+k+1}^{k} \end{aligned}</script><h3 id="抽屉原理与平均值原理"><a href="#抽屉原理与平均值原理" class="headerlink" title="抽屉原理与平均值原理"></a>抽屉原理与平均值原理</h3><h4 id="抽屉原理"><a href="#抽屉原理" class="headerlink" title="抽屉原理"></a>抽屉原理</h4><h5 id="第一抽屉原理"><a href="#第一抽屉原理" class="headerlink" title="第一抽屉原理"></a>第一抽屉原理</h5><p>如果将m个物件放入n个抽屉内，那么必有一个抽屉内至少有$[\frac{m-1}{n}]+1$个物件。</p>
<p>【推广】</p>
<p>如果将$m_1+m_2+…+m_n+1$个物件放入n个抽屉内，那么或者第一个抽屉内至少有$m_1+1$个物x    件，或者第二个抽屉内至少有$m_2+1$个物件……或者第n个抽屉内至少有$m_n+1$个物件。</p>
<h5 id="第二抽屉原理"><a href="#第二抽屉原理" class="headerlink" title="第二抽屉原理"></a>第二抽屉原理</h5><p>如果将m个物件放入n个抽屉内，那么必有一个抽屉内至多有$[\frac{m}{n}]$个物件。</p>
<p>【推广】</p>
<p>如果将$m_1+m_2+…+m_n-1$个物件放入n个抽屉内，那么或者第一个抽屉内至多有$m_1-1$个物件，或者第二个抽屉内至多有$m_2-1$个物件……或者第n个抽屉内至多有$m_n-1$个物件。</p>
<h4 id="平均值原理"><a href="#平均值原理" class="headerlink" title="平均值原理"></a>平均值原理</h4><p>（1）设$a_1,a_2,…,a_n$是实数，$A =\frac{1}{n}(a_1+a_2+…+a_n)$，则$a_1,a_2,…,a_n$中必有一个数不小于A，也有一个数不大于A。</p>
<p>（2）设$a_1,a_2,…,a_n$是实数，$G =\frac{1}{n}\sqrt[n]{a_1a_2…a_n}$，则$a_1,a_2,…,a_n$中必有一个数不小于G，也有一个数不大于G。</p>
<h3 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h3><p>生成函数的定义：</p>
<p>实数序列 $a_0,a_1,…,a_k,…$的生成函数是无穷级数</p>
<p>$G(x)=a_0+a_2x+…+a_kx^k+…=\sum_{k=0}^{\infty}a_kx^k$</p>
<p>${a_k}$的普通生成函数。</p>
<p>广义二项式系数：</p>
<p>$\dbinom{u}{k}=\left \{ \begin{aligned}&amp;u(u-1)(u-2)…(u-k+1)/k!,&amp;k&gt;0\\<br>&amp;1,&amp;k=0<br>\end{aligned}\right.$</p>
<p>【例】</p>
<p>$\begin{aligned}\dbinom{1/2}{3}&amp;=\frac{(1/2)(1/2-1)(1/2-2)}{3!}\\<br> &amp;=\frac{(1/2)(-1/2)(-3/2)}{6}\\<br> &amp;=1/16<br> \end{aligned}$</p>
<p>设$x$是实数，$|x|&lt;1$，$u$是实数，那么</p>
<p>$(1+x)^u=\sum_{k=0}^{\infty}\dbinom{u}{k}x^k$</p>
<h4 id="常用生成函数"><a href="#常用生成函数" class="headerlink" title="常用生成函数"></a>常用生成函数</h4><p>$\begin{aligned} &amp;\frac{1-x^{n+1}}{1-x}=\sum_{k=0}^{n}x^k\\<br>&amp;\\<br>&amp;\frac{1}{1-ax}=\sum_{k=0}^{\infty}a^kx^k\\<br>&amp;\\<br>&amp;\frac{1}{(1-x)^2}=\sum_{k=0}^{\infty}(k+1)x^k\\<br>&amp;\\<br>&amp;\frac{1}{(1-x)^n}=\sum_{k=0}^{\infty}C_{n+k-1}^{k}x^k\\<br>&amp;\\<br>&amp;\frac{1}{(1+x)^n}=\sum_{k=0}^{\infty}C_{n+k-1}^{k}(-1)^kx^k \end{aligned}$</p>
<h3 id="特殊计数序列"><a href="#特殊计数序列" class="headerlink" title="特殊计数序列"></a>特殊计数序列</h3><h4 id="Catalan数列"><a href="#Catalan数列" class="headerlink" title="Catalan数列"></a>Catalan数列</h4><p>前几项：$1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, ……$</p>
<p>即$c[0]=1,c[1]=1,c[2]=2…$</p>
<p>$\begin{aligned} &amp;递推式1：f[n]=\sum_{i=0}^{n-1}f[i]*f[n-i-1]\\<br>&amp;递推式2：f[n]=\frac{4n-2}{n+1}f[n-1]\\<br>&amp;组合式1：f[n]=\frac{C_{2n}^{n}}{n+1}\\<br>&amp;组合式2：f[n] = C_{2n}^{n}-C_{2n}^{n-1} \end{aligned}$</p>
<p>应用：</p>
<ol>
<li>二叉树计数1：已知二叉树有$n$个节点，能够构成$C_{n}$种不同的二叉树。（二叉搜索树）</li>
<li>二叉树计数2：已知二叉树的叶子$n$个，能够构成$C_{n-1}$种不同的二叉树。（二叉搜索树）</li>
<li>括号匹配数：一个合法的表达式由()包围，()可以嵌套和连接，给出$n$对括号，可以组成的合法表达式的个数为$C_{n}$。</li>
<li>划分问题：将一个凸$n+2$多边形区域分成三角形区域的方法数为$C_{n}$。</li>
<li>出栈问题1：一个栈的进栈序列为$1,2,3,..n$，不同的出栈序列有$C_{n}$种。</li>
<li>出栈问题2：有2n个人排成一行进入剧场。入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少种方法使得只要有10元的人买票，售票处就有5元的钞票找零。5元的相当于入栈，10元的相当于出栈，转化成上问题。</li>
<li>路径问题：在$n*n$的方格地图中，从一个角到另外一个角，不跨越对角线的路径数有$C_{n}$种。</li>
<li>握手问题：$2n$个人均匀坐在一个圆桌边上，某个时刻所有人同时与另一个人握手，要求手之间不能交叉，共有$C_{n}$种握手方法。</li>
</ol>
<h4 id="Fibonacci数列"><a href="#Fibonacci数列" class="headerlink" title="Fibonacci数列"></a>Fibonacci数列</h4><p>通项公式：$F_n=\frac{1}{\sqrt{5}}[(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n]$</p>
<p>递推式：</p>
<p>$F_n=F_{n-1}+F_{n-2}$</p>
<p>性质：</p>
<p>$\begin{aligned} &amp;F_1+F_1+F_2+F_3+…+F_n=F_{n+2}-1\\<br>&amp;\\<br>&amp;F_1+2F_2+3F_3+…+nF_n=nF_{n+2}-F_{n+3}+2\\<br>&amp;\\<br>&amp;F_1+F_3+F_5+…+F_{2n-1}=F_{2n}\\<br>&amp;\\<br>&amp;F_2+F_4+F_6+…+F_{2n}=F_{2n+1}-1\\<br>&amp;\\<br>&amp;F_1^2+F_2^2+F_3^2+…+F_n^2=F_nF_{n+1}\\<br>&amp;\\<br>&amp;F_{n-1}F_{n+1}-F_n^2=(-1)^n \end{aligned}$</p>
<p>定理：</p>
<p>$\begin{aligned} &amp;F_nF_m+F_{m-1}F_{n-1}=F_{m+n-1}\\<br>&amp;\\<br>&amp;F_mF_{n+1}+F_{m-1}F_n=F_{m+n}\\<br>&amp;\\<br>&amp;m=n时，\\<br>&amp;F_{2n-1}=F_n^2+F_{n-1}^2\\<br>&amp;\\<br>&amp;F_{2n}=(F_{n-1}+F_{n+1})F_n=(2F_{n-1}+F_n)F_n\\<br>&amp;\\<br>&amp;F_n整除F_m当且仅当n整除m，其中n\geq3\\<br>&amp;\\<br>&amp;任意连续三个Fibonacci数两两互素。 \end{aligned}$</p>
<h4 id="Lucas数列"><a href="#Lucas数列" class="headerlink" title="Lucas数列"></a>Lucas数列</h4><p>定义：</p>
<p>$L_n= \left\{\begin{aligned}&amp;2,&amp;n=1\\<br>&amp;1,&amp;n=2\\<br>&amp;L_{n-1}+L_{n-2},&amp;n\geq3<br>\end{aligned} \right.$</p>
<p>通项公式：</p>
<p>$L_n=(\frac{1+\sqrt{5}}{2})^n+(\frac{1-\sqrt{5}}{2})^n$</p>
<p>与Fibonacci数的关系：</p>
<p>$\begin{aligned} &amp;F_{2n}=L_nF_n\\<br>&amp;\\<br>&amp;L_n=F_{n-1}+F_{n+1}\\<br>&amp;\\<br>&amp;F_n=\frac{L_{n-1}+L_{n+1}}{5}\\<br>&amp;\\<br>&amp;L_n^2=5F_n^2+4(-1)^n \end{aligned}$</p>
<h4 id="Stirling数"><a href="#Stirling数" class="headerlink" title="Stirling数"></a>Stirling数</h4><h5 id="第一类Stirling数"><a href="#第一类Stirling数" class="headerlink" title="第一类Stirling数"></a>第一类Stirling数</h5><p>$S1(n,m)$表示的是将$n$个不同元素构成$m$个圆排列的数目。</p>
<p>递推式：</p>
<p>$S1(n,m)=(n-1)*S1(n-1,m)+S1(n-1,m-1)(n&gt;1,m&gt;1)$</p>
<p>边界条件：</p>
<p>$\begin{aligned}<br>&amp;S1(0,0)=1,S1(n,0) = 0\\<br>&amp;S1(n,n) = 1<br>\end{aligned}$</p>
<p>性质：</p>
<p>$\sum_{k=0}^{n}S1(n,k)=n!$</p>
<p>【例】$n$个仓库， $2n$把钥匙，$n$ 位官员。如果把$n$位官员分成$m$个不同的部，部中的官员数量与管理的仓库数量一致。有多少种方案使得所有同部的官员可以打开所有本部管理的仓库，而无法打开其他管理的仓库。（$n$把钥匙放到仓库，$n$把钥匙分给官员）<br>方案数即为$S1(n,m)n!$。</p>
<p>前面的是放到仓库里的方案数，后面说官员的分配方案。</p>
<h5 id="第二类Stirling数"><a href="#第二类Stirling数" class="headerlink" title="第二类Stirling数"></a>第二类Stirling数</h5><p>$S2(n,m)$表示的是把$n$个不同元素划分到$m$个集合的方案数。</p>
<p>递推式：</p>
<p>$S2(n,m)=m*S2(n-1,m)+S2(n-1,m-1)(1\leq m\leq n-1)$</p>
<p>边界条件：</p>
<p>$\begin{aligned}<br>&amp;S2(n,0)=0,S2(n,1)=1\\<br>&amp;S2(n,n)=1<br>\end{aligned}$</p>
<h2 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h2><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>[<a href="https://blog.csdn.net/weixin_38686780/article/details/82940573">https://blog.csdn.net/weixin_38686780/article/details/82940573</a>]<br>(<a href="https://blog.csdn.net/weixin_38686780/article/details/82940573">https://blog.csdn.net/weixin_38686780/article/details/82940573</a>)<br>[<a href="https://blog.csdn.net/qq_41552508/article/details/89159952">https://blog.csdn.net/qq_41552508/article/details/89159952</a>]<br>(<a href="https://blog.csdn.net/qq_41552508/article/details/89159952">https://blog.csdn.net/qq_41552508/article/details/89159952</a>)<br><a href="https://www.zhihu.com/question/27467617">https://www.zhihu.com/question/27467617</a></p>
<h3 id="平等博弈"><a href="#平等博弈" class="headerlink" title="平等博弈"></a>平等博弈</h3><h4 id="常见概念及定理"><a href="#常见概念及定理" class="headerlink" title="常见概念及定理"></a>常见概念及定理</h4><h5 id="组合游戏"><a href="#组合游戏" class="headerlink" title="组合游戏"></a>组合游戏</h5><p>公平组合游戏ICG — Impartial Combinatorial Games<br>游戏的胜负仅仅取决于当前状态，与谁在玩没有关系。</p>
<p>判定：</p>
<ol>
<li>2人博弈</li>
<li>当前状态的下一个状态的个数有限</li>
<li>每个状态，两人操作集合相同</li>
<li>交替移动</li>
<li>一个人不能移动就为输</li>
<li>有限步内终止<h5 id="P状态与N状态"><a href="#P状态与N状态" class="headerlink" title="P状态与N状态"></a>P状态与N状态</h5>P - 必败态<br>N - 必胜态</li>
<li>所有终止的状态是P状态</li>
<li>能一步到达P状态的是N状态</li>
<li><p>每一步都将到达N状态的为P状态</p>
<h5 id="SG函数和SG定理"><a href="#SG函数和SG定理" class="headerlink" title="SG函数和SG定理"></a>SG函数和SG定理</h5></li>
</ol>
<p>sg函数值的意义，如果$sg(x)=0$，那么x是必败态，否则x是必胜态。<br>定义：$sg(x)=min\{n\geq 0|n=sg(y),y\in  F(x)\}$</p>
<p>$F(x)$表示x所有的下一个状态的集合。</p>
<p>定义mex函数为不在一个集合里的最小非负整数。则</p>
<p>$sg(x)=mex\{sg(y)|y\in F(x)\}$</p>
<p>SG定理：</p>
<p>$sg(x_1,x_2,…,x_n)=sg(x_1) \oplus sg(x_2)\oplus … \oplus sg(x_n)$</p>
<p>求sg函数代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//f[i]代表可行的转移方式 k代表方式总数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[maxn], k, sg[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getsg</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sg, <span class="number">0</span>, <span class="keyword">sizeof</span> sg);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; f[j] &lt;= i &amp;&amp; j &lt;= k; ++j) &#123;</span><br><span class="line">            vis[sg[i - f[j]]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!vis[j]) &#123;</span><br><span class="line">                sg[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h4><h5 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h5><p>一堆n个物品，每人每次轮流从中取出$1 - m$个，最后取光者胜。<br>结论：如果$n \% (m+1)==0$那么后手胜，否则先手获胜。</p>
<h5 id="nim博弈"><a href="#nim博弈" class="headerlink" title="nim博弈"></a>nim博弈</h5><p>两个人玩取石子游戏，共有N堆石子，每个人每次可以从一堆石子里面任意多个石子，最后取光者胜。<br>结论：亦或和为0先手必败，否则先手必胜。</p>
<p>阶梯nim：n级台阶，每级台阶上放有石子。每人每次选一级台阶上的若干石子移到下一层。第0层为地面。不能移动的为输。<br>结论：奇数级台阶的亦或和为0先手必败，否则先手必胜。</p>
<h5 id="反nim博弈"><a href="#反nim博弈" class="headerlink" title="反nim博弈"></a>反nim博弈</h5><p>将nim改为最后取的人输。<br>必胜态有两种：</p>
<ol>
<li>所有石堆个数都是1,且有偶数堆。</li>
<li>如果存在某堆个数不为1,那么亦或和不为0。<h5 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h5>两个人玩取石子游戏，共有2堆石子，每个人可以选择从一堆石子里面取石子，也可以选择从两堆石子里面取相同数量的石子，最后取光者胜。<br>结论：必败局势为(a,b)(a&lt;b)，满足<br>$a=(int)(b-a)*\frac{\sqrt{5}+1}{2}$</li>
</ol>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; y)<span class="built_in">swap</span>(x, y);</span><br><span class="line">      <span class="keyword">double</span> r = (<span class="built_in">sqrt</span>(<span class="number">5.0</span>) + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">int</span>) ((<span class="keyword">double</span>) (y - x) * r) == x)cout &lt;&lt; <span class="string">&quot;houshou&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;xianshou&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h5 id="Moore’s-Nimk"><a href="#Moore’s-Nimk" class="headerlink" title="Moore’s Nimk"></a>Moore’s Nimk</h5><p>两个人玩取石子游戏，共有N堆石子，每个人每次可以从至多k堆石子里面任意多个石子，最后取光者胜。<br>结论：把n堆石子的石子数用二进制表示，统计每个二进制位上1的个数，若每一位上1的个数mod(k+1)全部为0，则必败。</p>
<h5 id="Fibonacci博弈"><a href="#Fibonacci博弈" class="headerlink" title="Fibonacci博弈"></a>Fibonacci博弈</h5><p>1堆石子有n个,两人轮流取。先取者第1次可以取任意多个，但不能全部取完。以后每次取的石子数不能超过上次取子数的2倍。最后取光者胜。<br>结论：先手必胜当且仅当识字数n不是Fibonacci数。</p>
]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构》 课程笔记</title>
    <url>/2021/04/23/data-structure/</url>
    <content><![CDATA[<p>参考书目主要为 王道考研系列的《数据结构》。该系列为本人准备考研时所整理。 描述语言为C语言，部分代码采用了C++风格的描述方式。</p>
<span id="more"></span>
<h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><p>一个程序应该包含两个方面的内容：</p>
<ol>
<li>对数据的描述：数据结构（data structure）</li>
<li>对操作的描述：算法（algorithm）</li>
</ol>
<p>计算机科学家沃斯提出一个公式：数据结构 + 算法 = 程序</p>
<p>完整的程序设计应该是：数据结构 + 算法 + 程序设计方法 + 语言工具</p>
<p>广义地说，为解决一个问题而采取的方法和步骤，称为“算法”。</p>
<p>计算机算法可以分为两大类别：</p>
<ol>
<li>数值运算算法：求数值解，例如求方程的根、函数的定积分等。</li>
<li>非数值计算：如图书检索、人事管理、行车调度等。</li>
</ol>
<p>算法的表示方法：自然语言、传统流程图、伪代码、PAD图。</p>
<h4 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h4><p><em>数据</em>： 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号集合。数据是计算机程序加工的原料。</p>
<p><em>数据元素</em>： 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成元素的不可分割的最小单位。</p>
<p><em>数据对象</em>： 数据对象是具有相同性质的数据元素的集合，是数据的一个子集。</p>
<p><em>数据类型</em>： 数据类型是一个值的集合和定义在此集合上的一组操作的总称。原子类型 — 值不可再分割的数据类型；结构类型 — 值可以再分解为若干成分（分量）的数据类型；抽象数据类型 — 抽象数据组织及与之相关的操作。</p>
<p><em>数据结构</em>： 相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构。</p>
<p>数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。</p>
<p>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p>
<p>抽象数据类型（ADT）描述了数据的逻辑结构和抽象运算，通常用（数据对象，数据关系，基本操作集）这样的三元组来表示，从而构成一个完整的数据结构定义。</p>
<p>逻辑结构指数据元素之间的逻辑关系，即从逻辑关系上描述数据，与数据的存储无关，独立于计算机。</p>
<p>逻辑结构分为线性结构和非线性结构。</p>
<p>线性结构：一般线性表、栈和队列、串、数组、广义表等。</p>
<p>非线性结构：集合、一般树、二叉树、图状结构或网状结构等。</p>
<p>存储结构指数据结构在计算机中的表示（映像），也称物理结构。包括数据元素的表示和关系的表示。</p>
<p>数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。</p>
<ol>
<li><p>顺序存储：逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p>
<pre><code>优点是可以实现随机存取，每个元素占用最少的存储空间；

缺点是只能使用相邻的一整块存储单元，可能产生较多的外部碎片。
</code></pre><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">注：</span><br><span class="line">内存碎片分为：内部碎片和外部碎片</span><br><span class="line">【内部碎片】</span><br><span class="line">内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；</span><br><span class="line">内部碎片是处于（操作系统分配的用于装载某一进程的内存）区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</span><br><span class="line">单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片。</span><br><span class="line">【外部碎片】</span><br><span class="line">外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</span><br><span class="line">外部碎片是处于任何两个已分配区域或页面之间的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。</span><br><span class="line">产生外部碎片的一种情况：</span><br><span class="line">举个例子，在内存上，分配三个操作系统分配的用于装载进程的内存区域<span class="selector-tag">A</span>、<span class="selector-tag">B</span>和C。假设，三个内存区域都是相连的。故而三个内存区域不会产生外部碎片。现在假设<span class="selector-tag">B</span>对应的进程执行完毕了操作系统随即收回了<span class="selector-tag">B</span>，这个时候<span class="selector-tag">A</span>和C中间就有一块空闲区域了。</span><br></pre></td></tr></table></figure>
</li>
<li><p>链式存储：不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</p>
<pre><code>优点是不会出现碎片现象，能充分利用所有存储单元；

缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。
</code></pre></li>
<li><p>索引存储：在存储元素信息的同时，建立附加的索引表。索引表中的每项称为索引项，一般形式为（关键字，地址）。</p>
<pre><code>优点是检索速度快；

缺点是附加的索引表额外占用存储空间，增加和删除数据时也要修改索引表，会花费较多的时间。
</code></pre></li>
<li><p>散列存储：（哈希-Hash-存储）根据元素的关键字直接计算出该元素的存储地址。</p>
<pre><code>优点是检索、增加和删除节点的操作都很快；

缺点是散列函数不好，则可能出现元素存储单元的冲突，解决冲突会增加时间和空间的开销。
</code></pre></li>
</ol>
<p>小补充：</p>
<p><em>循环队列是用顺序表表示的队列，是一种<strong>数据结构</strong>。</em></p>
<p><em>顺序表、哈希表、单链表是三种不同的<strong>数据结构</strong>，既描述逻辑结构，又描述存储结构和数据运算。</em></p>
<p><em>有序表指关键字有序的线性表，是<strong>逻辑结构</strong>。仅描述元素之间的逻辑关系。既可链式存储，又可顺序存储。</em></p>
<p><em>栈是一种抽象数据类型，可以采用顺序存储或链式存储，只表示<strong>逻辑结构</strong>。</em></p>
<p>数据的运算</p>
<p>施加在数据上的运算包括运算的定义和实现。</p>
<pre><code>运算的定义是针对逻辑结构的，指出运算的功能；

运算的实现是实现针对存储结构的，指出运算的具体操作步骤。
</code></pre><h4 id="算法和算法评价"><a href="#算法和算法评价" class="headerlink" title="算法和算法评价"></a>算法和算法评价</h4><p>算法是对特定问题求解步骤的一种描述，是智力呢个的有限序列，每条指令表示一个或多个操作。</p>
<p>算法具有5个重要特性：有穷性，确定性，可行性，输入，输出。</p>
<p>有穷性指必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</p>
<p>确定性指每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</p>
<p>可行性指算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</p>
<p>一个“好“算法应考虑的目标：</p>
<ol>
<li>正确性。</li>
<li>可读性。</li>
<li>健壮性。输入非法数据时，能适当做出反应或进行处理，而不会产生莫名其妙的输出结果。</li>
<li>效率与低存储量需求。效率指算法执行的时间，存储量指算法执行过程中所需要的最大存储空间。两者与问题的规模有关。</li>
</ol>
<p>时间复杂度</p>
<p>一个语句的频度指该语句在算法中被执行的次数。算法中所有语句的频度之和记为$T(n)$，它是该算法问题规模n的函数，时间复杂度主要分析$T(n)$的数量级。</p>
<p>算法中基本运算的频度与$T(n)$同数量级，因此通常采用算法中基本运算的频度$f(n)$来分析算法的时间复杂度。</p>
<p>因此，算法的时间复杂度记为$T(n) = O(f(n))$。</p>
<p>O的含义是$T(n)$的数量级。</p>
<p>一般是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p>
<p>常见渐进复杂度为：</p>
<script type="math/tex; mode=display">O(1)<O(log_2 n)<O(n)<O(n log_2 n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)</script><p>空间复杂度</p>
<p>空间复杂度$S(n)$定义为该算法所耗费的存储空间，它是问题规模n的函数。</p>
<p>一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。</p>
<p>若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。</p>
<p><strong>算法原地工作是指所需的辅助空间为常量，即O(1)。</strong></p>
<p><strong>【例题】</strong>（计算时间复杂度）：</p>
<p>一个算法所需的时间由下述递归方程表示，试求出该算法的时间复杂度的级别：</p>
<script type="math/tex; mode=display">T(n) = \left\{ \begin{aligned} &1,&n=1\\ &2T(n/2)+n,&n>1\end{aligned} \right.</script><p>式中，n是问题规模，设n是2的整数次幂。</p>
<p>设 $n=2^k(k \geq 0)$</p>
<p>根据题目定义有 $T(2^k) = 2T(2^{k-1})+2^k=2^2T(2^{k-2})+2*2^k$</p>
<p>由此可得一般递推公式 <script type="math/tex">T(2^k)=2^i T(2^{k-i})+i*2^k</script></p>
<p>进而得到 <script type="math/tex">T(2^k) = 2^kT(2^0)+k*2^k=(k+1)2^k</script></p>
<p>即 <script type="math/tex">T(n)=2^{log_2 n}+n*log_2 n=n+nlog_2 n</script></p>
<p>因此，时间复杂度为 $O(nlog_2 n)$。</p>
<h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><h4 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h4><p>线性表是具有相同数据类型的$n(n \geq 0)$个数据元素的有限序列，n为表长。$n=0$时线性表是一个空表。</p>
<p>若用L命名线性表，一般表示为： $L = (a_1,a_2,…,a_i,a_{i+1},…,a_n)$</p>
<p>式中，$a_1$是唯一的“第一个”数据元素，又称为“表头元素”；$a_n$是唯一的“最后一个”数据元素，又称为“表尾元素”。</p>
<p>除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。</p>
<p>线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构，两者属于不同层面的概念。</p>
<p>线性表的特点：</p>
<ol>
<li>表中元素个数有限。</li>
<li>表中元素有逻辑上的顺序性，表中元素有先后次序。</li>
<li>表中元素都是数据元素，每个元素都是单个元素。</li>
<li>表中元素的数据类型都相同，每个元素占有相同大小的存储空间。</li>
<li>表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。</li>
</ol>
<h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><h5 id="顺序表-1"><a href="#顺序表-1" class="headerlink" title="顺序表"></a>顺序表</h5><p>用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理上也相邻。</p>
<p>线性表中元素的位序是从1开始的，数组中元素的下标是从0开始的。</p>
<p>$i$是元素$a_i$在线性表中的位序。</p>
<p>C代码描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态分配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="keyword">int</span> MaxSize,length;</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line">L.data = (ElemType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType) * InitSize);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：动态分配不是链式存储，同样属于顺序存储结构，物理结构没有变化。</p>
<p>依然是随机存取的方式，只是分配的空间大小可以在运行时确定。</p>
<p>基本操作的实现：</p>
<ol>
<li><p>插入 - $O(n)$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= MaxSize) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = L.length;j &gt;= i;--j) L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 - $O(n)$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//e中返回被删除元素</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; L.length;++j) L.data[j - <span class="number">1</span>] =　L.data[j];</span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按值查找 - $O(n)$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList &amp;L,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; L.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="examples-1"><a href="#examples-1" class="headerlink" title="examples - 1"></a>examples - 1</h5><p>e.1 </p>
<p>长度为n的非空线性表采用顺序存储结构，在表的第$i$个位置插入一个元素，则$i$的合法范围是：$1 \leq i \leq n+1$</p>
<p>$n+1$表示在表尾追加元素。</p>
<p>e.2</p>
<p>已知在一维数组$S[m+n]$中依次存放两个线性表$A(a_1,a_2,…,a_m)$ $B(b_1,b_2,…,b_n)$。编写一个函数，将两个顺序表的位置互换，即将B放到A的前面。</p>
<p><em>思想：现将整个数组 S 逆置，此时得到$(b_n,b_{n-1},…,b_1,a_m,a_{m-1},…,a_1)$，再对前n个数和后m个数分别逆置，从而实现两个表的顺序互换。</em></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(ElemType S[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> arraySize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right || right &gt;= arraySize)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= mid - left;++i)&#123;</span><br><span class="line">        ElemType temp = S[left + i];</span><br><span class="line">        S[left + i] = S[right - i];</span><br><span class="line">        S[right - i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(ElemType S[],<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> arraySize)</span></span>&#123;</span><br><span class="line">    Reverse(S,<span class="number">0</span>,m+n<span class="number">-1</span>,arraySize);</span><br><span class="line">    Reverse(S,<span class="number">0</span>,n<span class="number">-1</span>,arraySize);</span><br><span class="line">    Reverse(S,n,m+n<span class="number">-1</span>,arraySize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.3</p>
<p>长度为$L(L\geq 1)$的升序序列$S$，处在第$\lceil L/2\rceil$个位置的数称为$S$的中位数。现有两个等长<strong>升序</strong>序列$A$和$B$，设计一个算法找到两个序列的中位数。</p>
<p><em>思想：</em></p>
<p><em>分别求出两个序列$A,B$的中位数$a,b$，依次执行：</em></p>
<ol>
<li><p><em>若$a=b$，则$a$或$b$即是所求中位数。</em></p>
</li>
<li><p><em>若$a&lt;b$，则舍弃$A$的较小的一半和$B$的较大的一半，两段要相等。</em></p>
</li>
<li><em>若$a&gt;b$，则舍弃$A$的较大的一半和$B$的较小的一半，两段要相等。</em></li>
</ol>
<p><em>在保留的序列中重复计算中位数并重复过程123，直到两个序列均含有一个元素为止，此时两个元素中的较小者就是中位数。</em></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">M_Search</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1, r1, a;</span><br><span class="line">    <span class="keyword">int</span> l2, r2, b;</span><br><span class="line">    l1 = l2 = <span class="number">0</span>;</span><br><span class="line">    r1 = r2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 != r1 || l2 != r2)&#123; <span class="comment">// 左闭右闭区间 相等即为单个元素</span></span><br><span class="line">        a = A[(l1 + r1) / <span class="number">2</span>];</span><br><span class="line">        b = B[(l2 + r2) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(a == b)<span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">            l1 = (l1 + r1) / <span class="number">2</span>;</span><br><span class="line">            r2 = (l2 + r2) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((r1 - l1 + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) l1++; <span class="comment">// 长度为偶数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r1 = (l1 + r1) / <span class="number">2</span>;</span><br><span class="line">            l2 = (l2 + r2) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((r2 - l2 + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) l2++; <span class="comment">// 长度为偶数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A[l1] &lt; B[l2]) <span class="keyword">return</span> A[l1];</span><br><span class="line">    <span class="keyword">return</span> B[l2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度为$O(log_2n)$，空间复杂度为$O(1)$。</p>
<p>e.4 </p>
<p>整数序列$A = (a_0,a_1,…,a_{n-1})$，其中$0 \leq a_i &lt; n\ (0\leq i &lt;n)$，如果存在元素出现超过$n/2$次，那么称该元素为主元素。设计算法，找出$A$的主元素，若存在，输出主元素，若不存在，输出$-1$。</p>
<p><em>思路：</em></p>
<ol>
<li><em>依次扫描数组中的每个元素，将第一个整数$Num$存到$c$中，记录$cnt$为$1$。</em></li>
<li><em>扫描接下来的元素，如果遇到的数仍为$Num$，就让$cnt+1$，否则$cnt-1$；$cnt$减到$0$时，将遇到的下一个整数存到$c$中，$cnt$重新记为$1$，开始新一轮计数。</em></li>
<li><em>重复2过程，直到扫描完全部数组元素。</em></li>
<li><em>判断$c$中的元素是否真的是主元素。再次扫描数组，统计$c$中的元素出现次数，若大于$n/2$，就是主元素；否则，序列中不存在主元素。</em></li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Majority</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, cnt = <span class="number">1</span>;</span><br><span class="line">    c = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] == c) cnt++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>) cnt--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            c = A[i];</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == c) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; n / <span class="number">2</span>) <span class="keyword">return</span> c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(n)$，空间复杂度$O(1)$。</p>
<h4 id="链式表示"><a href="#链式表示" class="headerlink" title="链式表示"></a>链式表示</h4><p>链式存储线性表时，不需要使用地址连续的存储单元，即不要求逻辑上相邻的元素在物理位置上也相邻，通过“链”建立起数据元素之间的逻辑关系。插入和删除操作不需要移动元素，而只需要修改指针。但失去随机存取的优点。</p>
<p>链表的每个结点都带有指针域，故而存储密度不够大，存储密度小于1。</p>
<h5 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h5><p>通过一组任意的存储单元来存储线性表中的数据元素。</p>
<p>对每个链表节点，除存放元素自身的信息外，还需存放一个后继的指针。</p>
<p>类型描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<p>单链表可以解决顺序表需要大量连续存储空间的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。</p>
<p>单链表元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的节点，查找某个特定的节点时，需要从表头开始遍历，依次查找。</p>
<p>通常用头指针来标识一个单链表，头指针为NULL时表示一个空表。</p>
<p>为了操作上的方便，在单链表第一个节点之前附加一个结点，称为头结点。</p>
<p>头结点的数据域可以不设任何信息，也可记录表长等信息；头结点的指针域指向线性表的第一个元素结点。</p>
<p>不管带不带头结点，头指针始终指向链表的第一个节点，头结点是带头结点的链表的第一个节点。</p>
<p>引入头结点的优点：</p>
<ol>
<li>第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一致，无需特殊处理。</li>
<li>无论链表是否为空，其头指针都指向头结点的非空指针，因此空表和非空表的处理也就得到了统一。</li>
</ol>
<p><strong>（增设头结点的目的是方便运算的实现）</strong></p>
<p>头插法建立单链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList L,<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 顺序相反 复杂度O(n)</span></span><br><span class="line">    <span class="comment">// 含有头结点</span></span><br><span class="line">    LNode *s;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> LNode);</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> LNode);</span><br><span class="line">        s-&gt;data = A[i];</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>尾插法建立单链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList L,<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 顺序相同 复杂度O(n)</span></span><br><span class="line">    <span class="comment">// 需要设置一个尾指针r</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> LNode);</span><br><span class="line">    LNode *s, *r;</span><br><span class="line">    r = L;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> LNode);</span><br><span class="line">        s-&gt;data = A[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = x;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按序号查找，按值查找：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复杂度均为O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 按序号查找</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> L; <span class="comment">// 返回头结点</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// i无效</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">// 设置计数</span></span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; cnt &lt; i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">LNode *<span class="title">LocateElem</span><span class="params">(LinkList L,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 按值查找 不存在返回NULL</span></span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>插入操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert_Elem</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 后插操作 先找前驱结点</span></span><br><span class="line">    LNode *p = GetElem(L, i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LNode *s;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert_Elem</span><span class="params">(LinkList L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 前插操作 先找前驱结点 交换前驱结点和当前插入结点存放的数据</span></span><br><span class="line">    LNode *p = GetElem(L, i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LNode *s;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    s-&gt;data = p-&gt;data;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Elem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">    LNode *p = GetElem(L, i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LNode *s;</span><br><span class="line">    s = p-&gt;next;</span><br><span class="line">    p-&gt;next = s-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除给定的结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete_Elem</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先将后继结点的值赋予自身 然后删除后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;</span><br><span class="line">    LNode *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>求表长：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h5><p>双链表有两个指针prior和next，分别指向其前驱结点和后继结点。</p>
<p>类型描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode, *DLinkList;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>各个操作均与单链表类似，注意指针的变化情况。</p>
<h5 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h5><ol>
<li><strong>循环单链表</strong></li>
</ol>
<p>最后一个结点的指针不是NULL而改为指向头结点，从而整个链表形成一个环。</p>
<p>判空的条件不是头结点的指针是否为空，而是它是否等于头指针。</p>
<p>在任何一个位置插入都是等价的，无需判断表尾。</p>
<p>循环单链表可以从任意一个结点开始遍历整个表。</p>
<p>若操作主要是在表头表尾进行的，可以只设置尾指针，对表头表尾的操作均是$O(1)$。</p>
<ol>
<li><strong>循环双链表</strong></li>
</ol>
<p>头结点的prior指针还要指向尾结点。</p>
<p>循环双链表为空链表时，头结点的prior和next都等于L。</p>
<h5 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h5><p>借助数组来描述线性表的链式存储结构，结点也有data和next两个域，这里的next指的是结点的相对地址（数组下标），又称游标。</p>
<p>和顺序表一样，静态链表也需要预先分配一块连续的内存空间。</p>
<p>类型描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125; SLinkList[MaxSize];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>静态链表通常以next == -1为结束标志。</p>
<p>常用操作与动态链表的相同，只需要修改指针而不需要移动元素。</p>
<h5 id="双指针法合集"><a href="#双指针法合集" class="headerlink" title="双指针法合集"></a>双指针法合集</h5><p><img src="\images\image-20201018190803114.png" alt="image-20201018190803114"></p>
<p><img src="\images\image-20201018190943885.png" alt="image-20201018190943885"></p>
<p><img src="\images\image-20201018191145293.png" alt="image-20201018191145293"></p>
<p><img src="\images\d1ac82780e5189d7d58406504c3b7b56c35165997bfbb4c325677af92ee2d483.gif" alt="快慢指针在环上追及"></p>
<p><img src="\images\image-20201018191232083.png" alt="image-20201018191232083"></p>
<p>补充：找到环的入口的方法。在快慢指针相遇点和起点处同时设置一个指针，两个指针每次走一步，相遇处即为环的入口点。</p>
<p><img src="\images\image-20201018193441089.png" alt="image-20201018193441089"></p>
<h5 id="examples-2"><a href="#examples-2" class="headerlink" title="examples - 2"></a>examples - 2</h5><p>e.1 </p>
<p>某线性表用带头结点的循环单链表存储，头指针是head，当head-&gt;next-&gt;next == head成立时，线性表的可能长度是</p>
<p><strong>$0$ 或 $1$</strong></p>
<p>e.2</p>
<p>设计一个递归算法，删除不带头结点的单链表L中所有值为x的点。</p>
<p><em>递归实现，函数 f(L,x) 的功能是删除以L为首节点指针的单链表中所有值为x的节点。边界为L为空。</em></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete_X</span><span class="params">(Linklist L, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用引用，直接对原链表进行操作</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;data == x)&#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        Delete_X(L, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Delete_X(L-&gt;next, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.3</p>
<p>设L为带头节点的单链表，试实现从尾到头反向输出每个结点的值。</p>
<p><em>递归输出较为方便。</em></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Print</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next != <span class="literal">NULL</span>) R_Print(L-&gt;next);</span><br><span class="line">    <span class="keyword">if</span>(L != <span class="literal">NULL</span>) print(L-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.4</p>
<p>给定两个单链表，编写算法找出两个链表的公共节点。</p>
<p><em>两个链表有公共节点，即两个链表从某一结点开始，它们的next都指向同一个节点。拓扑形状看起来像Y。</em></p>
<p><em>假设一个链表比另一个链表长k个结点，现在长的链表上遍历k个结点，然后再同步遍历，就能保证同时到达同一个节点。</em></p>
<p><em>时间复杂度O(len1 + len2)</em>。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">LNode* <span class="title">Search_First_Common</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = Length(L1), len2 = Length(L2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dis = <span class="number">0</span>;</span><br><span class="line">    LNode *l1, *l2;</span><br><span class="line">    <span class="comment">// l1 表示较长的 l2 表示较短的</span></span><br><span class="line">    <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">        l1 = L1-&gt;next;</span><br><span class="line">        l2 = L2-&gt;next;</span><br><span class="line">        dis = len1 - len2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l1 = L2-&gt;next;</span><br><span class="line">        l2 = L1-&gt;next;</span><br><span class="line">        dis = len2 - len1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(dis--) l1 = l1-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.5</p>
<p>两个整数序列$A = a_1,a_2,…,a_m$，$B = b_1,b_2,…,b_n$分别存入两个单链表中，设计一个算法，判断序列B是否是序列A的<strong>连续</strong>子序列。</p>
<p><em>朴素算法。操作从两个链表第一个结点开始，若对应数据相等，则后移指针，若不等，则A链表从上次开始比较结点的后继开始，B链表仍从第一个结点开始比较。</em></p>
<p><em>B链表到尾则表示匹配成功，A到尾而B没到尾则表示失败。</em></p>
<p><strong><em>可优化。</em></strong></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pattern</span><span class="params">(LinkList A, LinkList B)</span> </span>&#123;</span><br><span class="line">    LNode *p = A, *q = B;</span><br><span class="line">    LNode *pre = p;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; q)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == q-&gt;data)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            p = pre;</span><br><span class="line">            q = B;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.6</p>
<p>设计一个算法，判断一个链表是否有环，如果有，找出环的入口并返回，否则返回NULL。</p>
<p><em>设置快慢两个指针 fast 和 slow ，初始时都指向链表头head。</em></p>
<p><em>fast 每次走两步，slow每次走一步。fast 和 slow 指定会相遇。</em></p>
<p><em>接下来继续双指针法找到环的入口。</em></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">LNode* <span class="title">FindLoopStart</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LNode *fast, *slow;</span><br><span class="line">    fast = L;</span><br><span class="line">    slow = L;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">NULL</span>) fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(slow == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//没有环，走到了NULL</span></span><br><span class="line">    </span><br><span class="line">    LNode *p1 = L;</span><br><span class="line">    LNode *p2 = slow;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">        p1 = p1-&gt;next;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.7</p>
<p>设线性表$L = (a_1,a_2,…,a_{n-1},a_n)$采用带头节点的单链表保存，链表中结点定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;NODE;</span><br></pre></td></tr></table></figure>
<p>设计一个算法，空间复杂度为$O(1)$，时间上尽可能高效，重新排列L中的各个结点，得到线性表$L’ = (a_1,a_n,a_2,a_{n-1},a_3,a_{n-2}…)$。</p>
<p><em>双指针法，找到线性表的中间点。</em></p>
<p><em>后半段原地逆置。</em></p>
<p><em>前后两个半段依次选取节点，按要求重排。</em></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_list</span><span class="params">(NODE* L)</span></span>&#123;</span><br><span class="line">    NODE *p, *q;</span><br><span class="line">    p = L;</span><br><span class="line">    q = L;</span><br><span class="line">    <span class="keyword">while</span>(q-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(q != <span class="literal">NULL</span>) q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    NODE *r;</span><br><span class="line">    <span class="comment">// 头插法逆置</span></span><br><span class="line">    <span class="keyword">while</span>(q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        r = q-&gt;next;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NODE *s = L-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        r = q-&gt;next;</span><br><span class="line">        q-&gt;next = s-&gt;next;</span><br><span class="line">        s-&gt;next = q;</span><br><span class="line">        s = q-&gt;next;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">顺序表</th>
<th style="text-align:center">链表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">存取（读写方式）</td>
<td style="text-align:center">可以顺序存取，也可随机存取。</td>
<td style="text-align:center">只能从表头开始顺序存取元素。</td>
</tr>
<tr>
<td style="text-align:center">逻辑结构与物理结构</td>
<td style="text-align:center">逻辑上相邻的元素对应的物理存储位置也相邻</td>
<td style="text-align:center">逻辑上相邻元素物理存储位置不一定相邻；逻辑关系通过指针来表示</td>
</tr>
<tr>
<td style="text-align:center">按值查找</td>
<td style="text-align:center">无序$O(n)$；有序$O(log_2n)$</td>
<td style="text-align:center">$O(n)$</td>
</tr>
<tr>
<td style="text-align:center">按序号查找</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">$O(n)$</td>
</tr>
<tr>
<td style="text-align:center">插入、删除</td>
<td style="text-align:center">需要移动元素 $O(n)$</td>
<td style="text-align:center">只需修改相关结点的指针域 $O(n)$</td>
</tr>
<tr>
<td style="text-align:center">空间分配</td>
<td style="text-align:center">预分配过大导致大量空间闲置；过小会发生溢出。动态分配需要移动大量元素，导致操作效率变低。</td>
<td style="text-align:center">只要有内存空间就可以分配，操作灵活、高效</td>
</tr>
</tbody>
</table>
</div>
<p>如何选取存储结构</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">顺序表</th>
<th style="text-align:center">链表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">基于存储考虑</td>
<td style="text-align:center"></td>
<td style="text-align:center">难以估计线性表长度或存储规模时</td>
</tr>
<tr>
<td style="text-align:center">基于运算考虑</td>
<td style="text-align:center">常按序号访问元素、较稳定的线性表</td>
<td style="text-align:center">常插入、删除操作（虽然也要找位置，但主要是基于比较操作）</td>
</tr>
<tr>
<td style="text-align:center">基于环境考虑</td>
<td style="text-align:center">任何高级语言中均有数组类型</td>
<td style="text-align:center">基于指针，实现较为复杂</td>
</tr>
</tbody>
</table>
</div>
<h3 id="栈、队列、矩阵"><a href="#栈、队列、矩阵" class="headerlink" title="栈、队列、矩阵"></a>栈、队列、矩阵</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是只允许在一端进行插入或删除操作的线性表。首先栈是一种<strong>线性表</strong>，但限定这种线性表只能在一端进行插入和删除操作。</p>
<p>栈顶（Top） - 允许插入删除的一端</p>
<p>栈底（Bottom） - 固定的，不允许插入和删除的另一端</p>
<p>空栈 - 不含任何元素的空表</p>
<p>栈的操作特性可以明显地概括为后进先出 - LIFO</p>
<p>$n$个不同的元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C_{2n}^n$，即卡特兰数（Catalan）。</p>
<p>栈的基本操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(&amp;S)</span></span>;</span><br><span class="line"><span class="comment">//初始化一个空栈S</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(S)</span></span>;</span><br><span class="line"><span class="comment">//判断一个栈是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(&amp;S, x)</span></span>;</span><br><span class="line"><span class="comment">//进栈，若S未满，则加入x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(&amp;S, &amp;x)</span></span>;</span><br><span class="line"><span class="comment">//出栈，弹出栈顶元素，返回x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(S, &amp;x)</span></span>;</span><br><span class="line"><span class="comment">//得到栈顶元素，返回x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyStack</span><span class="params">(&amp;S)</span></span>;</span><br><span class="line"><span class="comment">//销毁栈，并释放S空间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h5><p>顺序栈的实现</p>
<p>顺序存储的栈称为顺序栈，利用一组连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针top指示当前栈顶元素的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始时，top = -1</span></span><br><span class="line"><span class="comment">//栈满时，top == MaxSize - 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基本运算的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    S.data[++S.top] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = S.data[S.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h5><p>让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</p>
<p>两个栈的栈顶指针都指向栈顶元素。top0 = -1 时0号栈为空，top1 = $MaxSize$ 时1号栈为空。</p>
<p>当且仅当两个栈顶指针相邻时，即 top1 - top0 = 1 时判断为栈满。</p>
<p>共享栈是为了更有效地利用存储空间，两个栈的空间相互调节，只有整个存储空间被占满时才发生上溢，存取数据的时间复杂度均为$O(1)$，存取效率不变。</p>
<h5 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h5><p>采用链式存储的栈称为链栈。</p>
<p>链栈的优点是便于多个栈共享存储空间和提高效率，且不存在栈满上溢的情况。</p>
<p>通常采用单链表实现，并规定所有的操作都是在单链表的表头进行的。</p>
<p>链栈没有头结点，$Lhead$ 直接指向栈顶元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *LinkStack;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>链式存储更便于结点的插入和删除，链栈的操作与链表类似，入栈和出栈都在表头进行。</p>
<p>对于不带头节点的链栈具体实现会有些不同。</p>
<h5 id="example"><a href="#example" class="headerlink" title="example"></a>example</h5><p>e.1 </p>
<p>栈和队列具有相同的<strong><u>逻辑结构</u></strong>。</p>
<p>栈和队列的逻辑结构都是相同的，都属于线性结构，只是它们对数据的运算不同。</p>
<p>e.2</p>
<p>设两个栈s1、s2都采用顺序栈的存储方式，并共享一个存储区$[0,maxsize - 1]$ ，为了尽量利用空间，减少溢出的可能，可采用栈顶相向、迎面增长的存储方式。设计相关入栈出栈操作算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType Stack[maxsize];</span><br><span class="line">    <span class="keyword">int</span> top[<span class="number">2</span>];</span><br><span class="line">&#125; stk;</span><br><span class="line"></span><br><span class="line">stk S;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回为0则表明错误</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i, ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i 为栈号</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(S.top[<span class="number">1</span>] - S.top[<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 栈满</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) S.Stack[++top[<span class="number">0</span>]] = x;</span><br><span class="line">    <span class="keyword">else</span> S.Stack[--top[<span class="number">1</span>]] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> i, ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(S.top[<span class="number">0</span>] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            x = S.Stack[S.top[<span class="number">0</span>]--];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else</span></span><br><span class="line">    <span class="keyword">if</span>(S.top[<span class="number">1</span>] == maxsize) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = S.Stack[S.top[<span class="number">1</span>]++];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.3</p>
<p>执行函数时，局部变量一般采用<strong>栈结构</strong>进行存储。</p>
<p>e.4</p>
<p>利用栈实现递归函数的非递归计算：</p>
<script type="math/tex; mode=display">P_n(x) = \left\{\begin{aligned}&1,&n = 0 \\ &2x, &n = 1 \\ &2xP_{n-1}(x) - 2(n-1)P_{n-2}(x),&n>1  \end{aligned}\right.</script><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自下向上的思路 依次从栈顶算到栈底</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 1010</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">double</span> val;</span><br><span class="line">    &#125; st[MaxSize];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span> , i;</span><br><span class="line">    <span class="keyword">double</span> a1 = <span class="number">1</span>, a2 = <span class="number">2</span> * x; <span class="comment">// 0 1初值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = n;i &gt;= <span class="number">2</span>;--i)&#123; <span class="comment">// 2以上全部入栈</span></span><br><span class="line">        top++;</span><br><span class="line">        st[top].N = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(top &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        st[top].val = <span class="number">2</span> * x * a2 - <span class="number">2</span> * (st[top].N - <span class="number">1</span>) * a1;</span><br><span class="line">        a1 = a2;</span><br><span class="line">        a2 = st[top].val;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意边界情况！！</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> a1;</span><br><span class="line">    <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。</p>
<p>操作特性是先进先出（FIFO）。</p>
<h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><p>分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头front和队尾rear。</p>
<p>rear指向队尾元素的下一个位置（也可指向队尾元素）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始条件 front = rear = 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可能会发生“上溢出”，但有时并不是真正的溢出，是一种“假溢出”。</p>
<h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><p>把存储队列元素的表从逻辑上视为一个环，称为循环队列。</p>
<p>当队首指针$Q.front = MaxSize - 1 $ 后，前进一个位置到0，利用除法取余实现。</p>
<p>初始时 $Q.front = Q.rear = 0$</p>
<p>队首进1(Pop) $Q.front = (Q.front + 1) \% MaxSize$</p>
<p>队尾进1(Push) $Q.rear = (Q.rear + 1)\%MaxSize$</p>
<p>队列长度 $(Q.rear + MaxSize - Q.front) \% MaxSize$</p>
<p>区分队空队满的三种方法：</p>
<ol>
<li><p>牺牲一个单元来区分队空队满，入队时少用一个单元。</p>
<p>队满条件： $(Q.rear + 1)\%MaxSize == Q.front$</p>
<p>队空条件： $Q.front == Q.rear $ （不变）</p>
<p>队列长度： $(Q.rear - Q.front + MaxSize) \%MaxSize$ （不变）</p>
</li>
<li><p>新增设一个表示元素个数的数据成员$Q.size$。</p>
<p>队满条件： $Q.size == MaxSize$</p>
<p>队空条件： $Q.size == 0$</p>
<p>两种情况下都有$Q.front == Q.rear$。</p>
</li>
<li><p>类型增设一个tag数据成员，区分队满队空，若因删除导致$Q.front == Q.rear$，则为队空；若因插入导致，则为队满。</p>
</li>
</ol>
<p>基本操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ekse <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(DqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><p>队列的链式存储称为链队列，本质上是一个同时带有队头指针和队尾指针的单链表。</p>
<p>头指针指向队头结点，尾指针指向队尾节点，即单链表的最后一个节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front, *rear;</span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通常将链队列设计成带头节点的单链表。</p>
<p>用单链表表示的链式队列特别适合数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</p>
<p>假如程序中要使用多个队列，最好也使用链式队列，这样不会出现存储分配不合理和“溢出”的问题。</p>
<p>基本操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> LinkNode);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> LinkNode);</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="comment">// 一个元素时删除后变空</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h5><p>双端队列是允许两端都可以进行入队和出队操作的队列，逻辑结构仍是线性结构。</p>
<p>队列的两端分别称为前端和后端，两端都可以入队和出队。</p>
<p>前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。</p>
<p>无论是前端还是后端出队，先出的元素排列在后出的元素的前面。</p>
<p>输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列。</p>
<p>输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列。</p>
<p>若某个端点插入的元素只能从该端点删除，则该双端队列退化成两个栈底相邻接的栈。</p>
<h5 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h5><p>e.1</p>
<p>用链式存储方式的队列进行删除操作时，需要：头尾指针可能都要修改。</p>
<p>注：队列中只有一个元素时，头尾指针可能都要修改。</p>
<p>e.2</p>
<p>若希望循环队列中的元素都能得到利用，需要设置一个标志域tag，并以tag的值为0或1来区分头指针front和队尾指针rear相同时队列的状态，编写相应出队入队算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始tag为0 出队置0 入队置1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear &amp;&amp; Q.tag == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    Q.tag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear &amp;&amp; Q.tag == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    Q.tag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="队列在计算机系统中的应用"><a href="#队列在计算机系统中的应用" class="headerlink" title="队列在计算机系统中的应用"></a>队列在计算机系统中的应用</h5><p>队列在计算机中应用广泛。</p>
<p>第一个方面是解决主机与外部设备之间速度不匹配的问题。即通过设置缓冲区的方式，缓冲区中所存储的数据就是一个队列。</p>
<p>第二个方面是解决由多用户引起的资源竞争问题。在一个带有多终端的计算机系统上，有多个用户需要CPU各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用CPU的请求。操作系统通常按照每个请求在时间上的先后顺序，排成一个队列，当相应的程序运行结束或用完规定的时间间隔后，令其出队，再把CPU分给对手请求的用户使用。</p>
<h4 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h4><p>数组是由$n(n\geq 1)$个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界。</p>
<p>数组是线性表的推广，一维数组可视为线性表，二维数组可视为元素也是定长线性表的线性表。数组一旦被定义，其维数和维界就不再改变。因此，数组只会有存取和修改元素的操作。</p>
<p>压缩存储：指为多个值相同的元素只分配一个存储空间，目的是为了节省存储空间。</p>
<p>特殊矩阵：指具有许多相同矩阵元素或零元素，且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。</p>
<p>稀疏矩阵：矩阵中非零元素的个数相对矩阵元素的个数来说非常少的矩阵。</p>
<p>稀疏矩阵可采用对应行列和元素构成一个三元组的形式 &lt; 行标， 列标， 值 &gt; 进行存储，然后在按照一定形式存储这些三元组。<strong>稀疏矩阵压缩后失去了随机存取的特性。</strong></p>
<p>稀疏矩阵的三元组既可以采用数组存储，也可以采用十字链表法存储。</p>
<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h4><p>字符串简称串。</p>
<p>串（String）是由零个或多个字符组成的有限序列，一般记为 $S = ‘a_1a_2…a_n’\ \ \ (n\geq 0)$ 。</p>
<p>其中，S是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或其他字符，其中字符的个数n称为串的长度。n = 0时的串称为空串（$\emptyset$）。</p>
<p>子串：串中任意个连续的字符组成的子序列称为该串的子串。</p>
<p>包含子串的串相应地称为主串。</p>
<p>某个字符在串中的序号称为该字符在串中的位置。子串在主串中的位置以子串的第一个字符在主串中的位置来表示。</p>
<p>两个串的长度相等且每个对应位置的字符都相等时，两个串才是相等的。</p>
<p>空格是特殊字符，由空格组成的串称为空格串。</p>
<p>串的逻辑结构与线性表相似，区别仅在于串的数据对象仅限定为字符集。在基本操作上串和线性表有较大区别。线性表主要以单个元素为操作对象，串的基本操作通常以子串为操作对象。</p>
<h4 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预定义最大长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxLen 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MaxLen];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆分配表示</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch; <span class="comment">// 使用 malloc 和 free 操作</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>块链表示：使用类似于线性表的链式存储结构，也可采用链表方式存储串值。在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构。最后一个结点占不满时通常用’#’补上。</p>
<p><img src="\images\1146465-20170526184608544-1286290170-1619159514470.png" alt="img"></p>
<h4 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">StrAssignn(&amp;T, chars); <span class="comment">//串赋值为chars</span></span><br><span class="line">StrCopy(&amp;T, S); <span class="comment">//S复制得到T</span></span><br><span class="line">StrEmpty(S); <span class="comment">//判S空</span></span><br><span class="line">StrCompare(S, T); <span class="comment">//比较S T大小</span></span><br><span class="line">StrLength(S); <span class="comment">//S长度</span></span><br><span class="line">SubString(&amp;Sub, S, pos, len); <span class="comment">//获得S从pos起长为len的子串</span></span><br><span class="line">Concat(&amp;T, S1, S2); <span class="comment">//T返回链接S1和S2的串</span></span><br><span class="line">Index(S, T); <span class="comment">// 定位操作 若S存在与T相同的子串 返回其在主串中的第一个位置</span></span><br><span class="line">ClearString(&amp;S); <span class="comment">// 清空S</span></span><br><span class="line">DestroyString(&amp;S); <span class="comment">//销毁S</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，$StrAssign,\ StrLength,\ StrCompare,\ Concat,\ SubString$ 5项构成穿类型的最小操作子集，即这些操作不可能用其它串操作实现。</p>
<h4 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h4><p>子串的定位操作通常称为串的模式匹配，它求的是子串（模式串）在主串中的位置。（Index）</p>
<p>这里采用定长顺序存储结构。</p>
<h5 id="简单模式匹配算法"><a href="#简单模式匹配算法" class="headerlink" title="简单模式匹配算法"></a>简单模式匹配算法</h5><p>最朴素的实现方式，从主串S的第一个字符起，与模式T的第一个字符比较，若相等，则继续逐个比较，否则从主串的下一个字符起，重新和模式的字符比较。以此类推，直到模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则称匹配成功。</p>
<p>时间复杂度为$O(nm)$ ，m n分别代表模式串和主串的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SString S, SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i -= (j - <span class="number">2</span>);</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 重新匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length) <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="改进的模式匹配算法-KMP"><a href="#改进的模式匹配算法-KMP" class="headerlink" title="改进的模式匹配算法 - KMP"></a>改进的模式匹配算法 - KMP</h5><h6 id="改进方向"><a href="#改进方向" class="headerlink" title="改进方向"></a>改进方向</h6><p>暴力较坏情况举例：$aaaaaaaaaaaaab$ 与 $aaaaab$</p>
<p>暴力低效的根源：每趟匹配失败都是模式后移一位再从头开始比较。而某趟已匹配相等的字符序列是模式的某个前缀，这种频繁的重复比较相当于模式串在不断地进行自我比较，这就是低效的根源。</p>
<p>如果模式中，已经匹配相等的前缀序列中有某个后缀正好是模式的前缀，那么就可以将模式向后滑动到与这些相等字符对齐的位置，<strong>主串的指针无需回溯</strong>，并继续从该位置开始进行比较。而模式向后滑动位数的计算仅与模式本身的结构有关，与主串无关。</p>
<h6 id="最长相等前后缀"><a href="#最长相等前后缀" class="headerlink" title="最长相等前后缀"></a>最长相等前后缀</h6><p>前缀：除最后一个字符以外，字符串的所有头部子串。</p>
<p>后缀：除第一个字符外，字符串所有的尾部子串。</p>
<p>部分匹配值（PM）：字符串的前缀和后缀的最长相等前后缀长度。</p>
<p>【例】对于串 $”ababa”$ </p>
<p>前缀：$\{a,\ ab,\ aba,\ abab\}$</p>
<p>后缀：$\{a,\ ba,\ aba,\ baba\}$</p>
<p>公共元素：$\{a,\ ,aba\}$</p>
<p>部分匹配值：$3$</p>
<p>串 $”ababa”$ 的部分匹配值的表为</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">PM</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</div>
<p>00123分别代表串：</p>
<p>$a$，</p>
<p>$ab$，</p>
<p>$aba$，</p>
<p>$abab$，</p>
<p>$ababa$，</p>
<p>的部分匹配值。</p>
<p>得到PM表后进行匹配，如果出现不匹配的情况，那么相应的移动位数的计算方法为</p>
<p><strong>移动位数 = 已匹配的字符数 - 对应的部分匹配值</strong></p>
<p>整个匹配过程，主串不回退。</p>
<p>时间复杂度为$O(n+m)$。</p>
<h6 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a>next 数组</h6><p><strong>移动位数 = 已匹配的字符数 - 对应的部分匹配值</strong></p>
<p>可写成：$Move=(j-1) - PM[j-1]$</p>
<p>用起来可能会不方便，因此将PM表整体右移一位，得到next数组。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">next</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<p>第一个位置用-1来填充，即$(j-1) - (-1)$，若第一个元素匹配失败，需要将子串向右移动一位，而不需要计算子串移动的位数。此时主串指针右移，子串指针不变。</p>
<p>最后一个PM值没有用处，因此可以舍去。</p>
<p>因而改写为：$Move = (j-1) - next[j]$</p>
<p>这样$j$就回退到：$j = next[j] + 1$</p>
<p>有时为了公式更加简洁、计算更简单，将next数组整体+1。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">next</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</div>
<p>此时指针变化为$j = next[j]$。</p>
<p>next[j]的含义为：<strong>在子串的第j个字符发生失配时，则跳转到子串的next[j]位置重新与主串当前位置进行比较。</strong></p>
<p>next函数公式：</p>
<script type="math/tex; mode=display">next[j] = \left\{
\begin{aligned}
&0,&j=1\\
&max\{k|1<k<j\ \&\ 'p_1...p_{k-1}' = 'p_{j-k+1}...p_{j-1}'\}, & 集合非空\\&1,&其他情况
\end{aligned}
\right.</script><p>求解步骤：</p>
<ol>
<li>next[1] = 0</li>
<li>设next[j] = k。则<ol>
<li>若$p_k = p_j$，则此时next[j + 1] = k + 1。</li>
<li>若$p_k\neq p_j$，则next[j+1] = next[next…[k]] + 1。</li>
</ol>
</li>
</ol>
<p>$p_k\neq p_j$时，即序列 $’p_1…p_{k-1}p_k’$ 与序列 $’p_{j-k+1}…p_{j-1}p_j’$ 在匹配的过程中，在$p_k$位置发生失配。</p>
<p>发生失配意味着要向前移动next[k]个单位继续匹配，如果还不可的话继续移动。</p>
<p>next数组计算函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T, <span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j; <span class="comment">// pi == pj 的情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j]; <span class="comment">// pi != pj 的情况 不断循环 直到j降到不再失配为止</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="KMP代码部分"><a href="#KMP代码部分" class="headerlink" title="KMP代码部分"></a>KMP代码部分</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])&#123; <span class="comment">// 继续比较</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 失配</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)<span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="next函数进一步优化-nextval"><a href="#next函数进一步优化-nextval" class="headerlink" title="next函数进一步优化 - nextval"></a>next函数进一步优化 - nextval</h6><p>原本KMP算法不优的原因。</p>
<p>$’aaaab’$ 进行匹配时 $’aaabaaaaab’$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">aaabaaaaab</span></span><br><span class="line"><span class="comment">aaaab!!</span></span><br><span class="line"><span class="comment"> aaaab!!</span></span><br><span class="line"><span class="comment">  aaaab!!</span></span><br><span class="line"><span class="comment">   aaaab!!</span></span><br><span class="line"><span class="comment">    aaaab</span></span><br><span class="line"><span class="comment">多余4次</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>根源在于出现了$p_j = p_{next[j]}$。</p>
<p>因此需要将出现这种情况的next[j]修正为next[next[j]]。</p>
<p>优化后的next数组常更新命名为nextval。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T, <span class="keyword">int</span> nextval[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="comment">// pi == pj 的情况</span></span><br><span class="line">            <span class="keyword">if</span>(T.ch[i] != T.ch[j]) nextval[i] = j; <span class="comment">// 改动</span></span><br><span class="line">            <span class="keyword">else</span> nextval[i] = nextval[j]; <span class="comment">// 改动</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// pi != pj 的情况 不断循环 直到j降到不再失配为止</span></span><br><span class="line">            j = nextval[j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="树、二叉树"><a href="#树、二叉树" class="headerlink" title="树、二叉树"></a>树、二叉树</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h5 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h5><p>树是n个结点的有限集。n = 0时，称为空树。</p>
<p>任意一棵非空树应该满足：</p>
<ol>
<li>有且仅有一个特定的称为根的结点。</li>
<li>n &gt; 1时，其余结点可以非为m(m &gt; 0)个互不相交的有限集$T_1,T_2,…,T_m$，其中每个集合本身又是一棵树，并且称为根的子树。</li>
</ol>
<p>树的定义是递归的。</p>
<p>树作为一种逻辑结构，也是一种分层结构。</p>
<p>具有以下特点：</p>
<ol>
<li>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。</li>
<li>树中所有结点可以有0个或多个后继。</li>
</ol>
<p>树适合表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上层的一个结点（即其父结点）有直接关系，根结点没有直接上层结点，因此在n个结点的树中有n - 1条边。而树中每个结点与其下一层的0个或多个结点有直接关系（子女结点）。</p>
<h5 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h5><p><strong>祖先</strong> - 到根的唯一路径上的任意结点（<strong>子孙</strong>）。</p>
<p><strong>双亲</strong> - 路径上最近的结点（<strong>孩子</strong>）。</p>
<p>树中任意一个结点的孩子个数称为该结点的<strong>度</strong>。<strong>树中结点的最大度数称为树的度</strong>。</p>
<p>度大于0的结点称为<strong>分支结点</strong>（<strong>非终端结点</strong>）；度为0的结点成为<strong>叶子结点</strong>（<strong>终端结点</strong>）。<strong>每个结点的分支数就是该结点的度。</strong></p>
<p>结点的<strong>层次</strong>从树根开始定义，根结点为第一层，它的子结点为第2层，以此类推。</p>
<p>双亲结点在同一层的结点互为<strong>堂兄弟</strong>。</p>
<p>结点的<strong>深度</strong>是从根结点开始自顶向下逐层累加的。</p>
<p>结点的<strong>高度</strong>是从叶结点开始自底向上逐层累加的。</p>
<p>树的<strong>高度</strong>（<strong>深度</strong>）是树中结点的最大层数。</p>
<p>树中结点的各子树从左到右是有次序的，不能互换，则该树为<strong>有序树</strong>，否则称为<strong>无序树</strong>。</p>
<p>树中两个结点之间的<strong>路径</strong>是由这两个结点之间所经过的结点序列构成的，<strong>路径长度</strong>是路径上所经过的边的个数。（同一个双亲的两个孩子间不存在路径，因为树中的分支是有向的，从双亲指向孩子，路径都是从上向下的）</p>
<p>树的路径长度是指树根到每个结点的路径长度总和，根到每个结点的路径长度的最大值应该是树的高度 - 1。</p>
<p><strong>森林</strong>是$m(m\geq 0)$棵互不相交的树的集合。树的根结点删去就成了森林，m棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树。</p>
<h5 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h5><ol>
<li>树的结点数 = 所有的结点的度数 + 1。</li>
<li>度为m的树中第$i$层上至多有$m^{i-1}$个结点$(i\geq 1)$。</li>
<li>高度为h的m叉树至多有$(m^h - 1)/(m-1)$个结点。</li>
<li>具有n个结点的m叉树的最小高度为$\lceil log_m(n(m-1)+1) \rceil$。</li>
</ol>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><h5 id="二叉树定义和特性"><a href="#二叉树定义和特性" class="headerlink" title="二叉树定义和特性"></a>二叉树定义和特性</h5><p>二叉树也是一种树形结构，其特点是每个结点至多有两棵子树（即二叉树中不存在度大于2的结点）。</p>
<p>且二叉树的子树有左右只分，次序不能任意颠倒。即使数中结点只有一棵子树，也要区分左右子树。</p>
<p>二叉树是$n(n\geq 0)$个结点的有限集合，递归形式定义：</p>
<ol>
<li>或者为空二叉树，n = 0。</li>
<li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树有分别是一棵二叉树。</li>
</ol>
<p>度为2的有序树和二叉树之间的区别：</p>
<ol>
<li>度为2的有序树至少3个结点，二叉树可为空。</li>
<li>度为2的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这个孩子就无需区分左右顺序，而二叉树无论怎样都应该区分左右，是确定的，不是相对于另一个而言的。</li>
</ol>
<h5 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h5><p>满二叉树：每层都含有最多的结点。共$2^h - 1$个结点。编号顺序自上而下自左至右，$i$的左右儿子分别为 $2i$ 和 $2i+1$。$i$ 的双亲为 $\lfloor i/2 \rfloor$。$i$ 为奇数则是双亲的右结点，偶数则为左结点。</p>
<p>完全二叉树：出最后一层外全满。</p>
<ol>
<li>若$i\leq \lfloor n/2\rfloor$，则结点 $i$ 为分支结点，否则为叶子结点。</li>
<li>叶子结点只可能在层次最大的两层上。</li>
<li>度为1的结点可能只有1个，且该结点无右孩子。</li>
<li>一旦某结点 $i$ 只有左孩子，那么大于 $i$ 的所有结点均为叶子结点。</li>
<li>若n为奇数，那么每个分支结点都有左孩子和右孩子，否则会有一个只有左孩子。</li>
</ol>
<p>二叉排序树：左子树上所有结点的关键字均小于根结点的关键字，右子树上的所有结点的关键字均大于根结点的关键字，左右子树又各是一棵二叉排序树。</p>
<p>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1。</p>
<h5 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h5><ol>
<li>非空二叉树的叶子结点数等于度为2的结点数+1。即，$n_0 = n_2 + 1$。</li>
<li>非空二叉树上第 $k$ 层上至多有 $2^{k-1}$ 个结点（$k\geq 1$）。</li>
<li>高度为h的二叉树至多有$2^h - 1$个结点（$h\geq 1$）。</li>
<li>具有n个（$n&gt;0$）结点的完全二叉树的高度为$\lceil log_2(n+1)\rceil$ 或 $\lfloor log_2n  \rfloor + 1$。</li>
</ol>
<h5 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h5><p>二叉树的存储结构是指用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为 $i$ 的结点元素存储在一维数组下标为 $i-1$ 的分量中。</p>
<p>完全二叉树和满二叉树适合采用顺序存储。（数组下标1开始存储）</p>
<p>树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。</p>
<p>对于一般的二叉树，这种方法并不适合。</p>
<p>链式存储结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">// 左右孩子指针</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在含有n个结点的二叉链表中，含有n + 1个空链域。</p>
<h5 id="examples-1-1"><a href="#examples-1-1" class="headerlink" title="examples - 1"></a>examples - 1</h5><p>e.1 </p>
<p>设二叉树有2n个结点，且m&lt;n，则不可能存在（）的结点。</p>
<p>A. n个度为0</p>
<p>B. 2m个度为0</p>
<p>C. 2m个度为1</p>
<p>D. 2m个度为2</p>
<p>A. 可能，例n = 1，两个结点时。</p>
<p>B. 可能，例n = 3，$n_0 = 2,n_1 = 3,n_2 = 1$。</p>
<p>D. 可能，例n = 3，$n_0 = 3,n_1 = 1,n_2= 2$。</p>
<p>C. 不可能。</p>
<p>$n_0 = n_2 + 1$</p>
<p>$2n = n_0+n_1 + n_2$</p>
<p>代入得，$2n = 2n_2 + 1 + n_1$</p>
<p>于是，$n_1$ 一定为奇数。</p>
<p>e.2</p>
<p>一棵高度为h的满m叉树，按层次自顶向下，同一层次自左向右，顺序从1开始对全部结点进行编号。则</p>
<p>（1）各层结点数：$m^{k-1}$</p>
<p>（2）编号为 $i$ 的结点的双亲结点（若存在）的编号。</p>
<p>结点 $i$ 的第1个子女的编号为 $j = (i-1)*m + 2$ ，那么结点 $i$ 的双亲编号为$\lfloor (i-2)/m \rfloor + 1\ \ (i&gt;1)$</p>
<p>（3）编号为 $i$ 的结点的第 $k$ 个孩子结点（若存在）的编号。</p>
<p>结点 $i$ 的第 $k$ 个孩子结点的编号为 $(i-1)*m+1+k$。</p>
<p>（4）编号为 $i$ 的结点有右兄弟的条件是什么。右兄弟的编号是多少。</p>
<p>结点 $i$ 不是其双亲的第 $m$ 个子女时才有右兄弟。当结点的编号 $(i-1)\%m \neq 0$ 时才有右兄弟 $i+1$。</p>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。</p>
<p>由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，使二叉树上的结点能够排列在一个线性队列上，便于遍历。</p>
<h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p>若二叉树为空，则什么也不做；否则：</p>
<ol>
<li>访问根结点。</li>
<li>先序遍历左子树。</li>
<li>先序遍历右子树。</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>若二叉树为空，则什么也不做；否则：</p>
<ol>
<li>中序遍历左子树。</li>
<li>访问根结点。</li>
<li>中序遍历右子树。</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>若二叉树为空，则什么也不做；否则：</p>
<ol>
<li>后序遍历左子树。</li>
<li>后序遍历右子树。</li>
<li>访问根结点。</li>
</ol>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="三种遍历总结"><a href="#三种遍历总结" class="headerlink" title="三种遍历总结"></a>三种遍历总结</h5><p>三种遍历算法中，递归遍历左右子树的顺序都是固定的，区别只是访问根结点的顺序不同。</p>
<p>不管采取哪种遍历算法，每个结点都被访问一次且仅访问一次。</p>
<p>时间复杂度都是$O(n)$。</p>
<p>递归遍历中，递归工作栈的栈深恰好为树的深度，最坏情况下，二叉树是有$n$个结点且深度为$n$的单支树，此时空间复杂度为$O(n)$。</p>
<h5 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h5><p>利用栈来实现。</p>
<p>对于后序非递归遍历，当一个结点的左右子树都被访问后才会出栈。此时栈内的元素恰好是当前结点的全部祖先。</p>
<h6 id="中序遍历非递归实现"><a href="#中序遍历非递归实现" class="headerlink" title="中序遍历非递归实现"></a>中序遍历非递归实现</h6><p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder2</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BitTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123; <span class="comment">// 一直向左</span></span><br><span class="line">            Push(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 出栈 转向右子树</span></span><br><span class="line">            Pop(S, p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="先序遍历非递归实现"><a href="#先序遍历非递归实现" class="headerlink" title="先序遍历非递归实现"></a>先序遍历非递归实现</h6><p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder2</span><span class="params">(BitTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            Push(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Pop(S, p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="后序遍历非递归实现"><a href="#后序遍历非递归实现" class="headerlink" title="后序遍历非递归实现"></a>后序遍历非递归实现</h6><p>要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点。</p>
<p>思路：从根结点开始，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点。按相同的规则访问右子树，右子树为空或右子树刚被访问完之后，就能保证正确的访问顺序。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BitTree p = T;</span><br><span class="line">    BitTree r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// r用来标记最近访问过的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            push(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            GetTop(S, p); <span class="comment">// p = S.top(); 只是得到栈顶元素 非出栈</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)&#123;</span><br><span class="line">                <span class="comment">// 如果右子树是r 那么表示刚刚被访问过 那么不该向右走</span></span><br><span class="line">                <span class="comment">// 右子树存在 先向右再向左转 正常遍历 注意压栈</span></span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">                Push(S, p);</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右子树不存在 访问该子树根结点 并标记</span></span><br><span class="line">                Pop(S, p);</span><br><span class="line">                visit(p);</span><br><span class="line">                r = p;</span><br><span class="line">                p = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h5><p>即按二叉树从上到下、从左至右的方式依次进行访问。</p>
<p>借助一个队列。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelQueue</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q, T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q, p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>) EnQueue(Q, p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>) EnQueue(Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h5><p>由先序序列和中序序列可以唯一确定一棵二叉树。（不断利用先序的根分割中序的左右子树）</p>
<p>由后续序列和中序序列可以唯一确定一棵二叉树。</p>
<p>由层次序列和中序序列也可确定。</p>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（除第一个和最后一个外），都有一个直接前驱和直接后继。</p>
<p>传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱后后继。</p>
<p>链式存储的n个结点的二叉树中的空指针数为$n+1$ ，利用这些空指针来存放其前驱或后继的指针。</p>
<p>可以加快查找结点前驱和后继的速度。</p>
<p>规定：</p>
<ol>
<li>若无左子树，令 $lchild$ 指向其前驱结点。</li>
<li>若无右子树，令 $rchild$ 指向其后继结点。</li>
</ol>
<p>因此，每个结点的信息增加两个标志域标识指针域是指向左（右）孩子还是指向前驱（后继）。</p>
<p>结点结构： <script type="math/tex"><lchild, ltag,data,rtag,rchild></script> 。</p>
<p>代码描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag; <span class="comment">// 为0表示是否指向左右孩子 为1表示是否指向前后继</span></span><br><span class="line">&#125;ThreadNode, *ThreadTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="中序线索二叉树的构造"><a href="#中序线索二叉树的构造" class="headerlink" title="中序线索二叉树的构造"></a>中序线索二叉树的构造</h5><p>二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索。</p>
<p>前驱或后继的信息只能在遍历时才能得到，因此线索化一棵二叉树的本质就是遍历一次二叉树。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p, ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    InThread(p-&gt;lchild, pre);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左子树为空 建立前驱线索</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild = p;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pre = p;</span><br><span class="line">    InThread(p-&gt;rchild, pre);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T, pre);</span><br><span class="line">        <span class="comment">// 需要处理遍历的最后一个结点</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了方便，可以在二叉树的线索链表上也添加一个头结点 $Head$ 。</p>
<p>Head 的左指针 $lchild$ 指向二叉树的根结点，$rchild$ 指针域的指针指向中序遍历访问的最后一个结点。</p>
<p>二叉树中序序列中的第一个结点的 $lchild$ 域指针和最后一个结点的 $rchild$ 域指针均指向Head。</p>
<p>这样就建立了一个双向线索检索表，方便从前往后或从后往前对线索二叉树进行遍历。</p>
<h5 id="中序线索二叉树的遍历"><a href="#中序线索二叉树的遍历" class="headerlink" title="中序线索二叉树的遍历"></a>中序线索二叉树的遍历</h5><p>求中序线索二叉树中中序序列下第一个和最后一个结点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">FirstNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadNode *<span class="title">LastNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    whlie(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>求中序线索二叉树中结点p在中序序列下的后继和前驱：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> FirstNode(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadNode *<span class="title">PreNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> LastNode(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不含头结点的中序线索二叉树的中序遍历算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = FirstNode(T); p != <span class="literal">NULL</span>; p = NextNode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="先序线索二叉树和后续线索二叉树"><a href="#先序线索二叉树和后续线索二叉树" class="headerlink" title="先序线索二叉树和后续线索二叉树"></a>先序线索二叉树和后续线索二叉树</h5><p>代码类似，只需变动线索化构造的代码与调用线索化左右子树递归函数的位置。</p>
<p>先序线索二叉树中找结点的后继：</p>
<ol>
<li>如果有左孩子，则左孩子就是后继。</li>
<li>如果有右孩子，则右孩子就是后继。</li>
<li>如果为叶结点，则右链域直接指示了结点的后继。</li>
</ol>
<p>后序线索二叉树中找结点的后继：</p>
<ol>
<li>若结点 x 是二叉树的根，则其后继为空。</li>
<li>若结点 x 是其双亲的右孩子，或是其双亲的左孩子且双亲的右孩子为空，则其后继为双亲。</li>
<li>若结点 x 是其双亲的左孩子，且其双亲有右子树，则其后继为双亲右子树上按后序遍历出的第一个结点。</li>
</ol>
<h4 id="examples-2-1"><a href="#examples-2-1" class="headerlink" title="examples - 2"></a>examples - 2</h4><p>e.1</p>
<p>给出二叉树的自下而上、从右到左的层次遍历算法。</p>
<p>思想：利用原有的层次遍历算法，出队的同时将各结点指针入栈，在所有结点入栈后再从栈顶依次访问即为所求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InvertLevel</span><span class="params">(BitTree bt)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack S;</span><br><span class="line">    Queue Q;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    EnQueue(Q, bt);</span><br><span class="line">    BitTree p;</span><br><span class="line">    <span class="keyword">while</span>(IsEmpty(Q) == <span class="number">0</span>)&#123;</span><br><span class="line">        DeQueue(Q, p);</span><br><span class="line">        Push(S, p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild) EnQueue(Q, p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild) EnQueue(Q, p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(IsEmpty(S) == <span class="number">0</span>)&#123;</span><br><span class="line">        Pop(S, p);</span><br><span class="line">        visit(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.2</p>
<p>假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。</p>
<p>设置变量 level 记录当前层数。</p>
<p>设置变量 last 指向当前层的最右结点。</p>
<p>每次层次遍历出队时与 last 指针比较，若两者相等，则层数加1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BtDepth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>, level = <span class="number">0</span>;</span><br><span class="line">    BiTree Q[MaxSize];</span><br><span class="line">    Q[++rear] = T;</span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">while</span>(front &lt; rear)&#123;</span><br><span class="line">        p = Q[++front];</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild) Q[++rear] = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild) Q[++rear] = p-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span>(front == last)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            last = rear; <span class="comment">// last 指向下层最右结点 即当前刚入队的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.3</p>
<p>设一棵二叉树中各结点的值互不相同。先序遍历序列和中序遍历序列分别存于两个一维数组A[] B[]中。</p>
<p>建立该二叉树的二叉链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">PreInCreat</span><span class="params">(ElemType A[], ElemType B[], <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// l1 r1 分别代表先序的第一和最后一个下标</span></span><br><span class="line">    <span class="comment">// l2 r2 分别代表中序的第一和最后一个下标</span></span><br><span class="line">    <span class="comment">// 初始调用 l1 = l2 = 1; r1 = r2 = n;</span></span><br><span class="line">    </span><br><span class="line">    root = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> BiTNode);</span><br><span class="line">    root-&gt;data = A[l1];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = l2;</span><br><span class="line">    <span class="keyword">for</span>(;B[mid] != root-&gt;data; ++mid); <span class="comment">// 找到根结点在中序序列中的划分</span></span><br><span class="line">    <span class="keyword">int</span> llen = mid - l2;</span><br><span class="line">    <span class="keyword">int</span> rlen = r2 - mid;</span><br><span class="line">    <span class="comment">// 计算左右子树的长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(llen) root-&gt;lchild = PreInCreat(A, B, l1 + <span class="number">1</span>, l1 + llen, l2, l2 + llen - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(rlen) root-&gt;rchild = PreInCreat(A, B, r1 - rlen + <span class="number">1</span>, r1, r2 - rlen + <span class="number">1</span>, r2);</span><br><span class="line">    <span class="keyword">else</span> root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.4</p>
<p>判断一棵二叉树是不是完全二叉树。采用二叉链表的方式存储。</p>
<p>层次遍历。无论是否是空都入队。</p>
<p>若当前队首元素时NULL，那么判断队列后面的元素中是否会出现非NULL的元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsComplete</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Queue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 空树是</span></span><br><span class="line">    </span><br><span class="line">    EnQueue(Q, T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q, p);</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            <span class="comment">// 无条件入队 无论是否是NULL</span></span><br><span class="line">            EnQueue(Q, p-&gt;lchild);</span><br><span class="line">            EnQueue(Q, p-&gt;rchild);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第一次出现NULL 即可判断出结果</span></span><br><span class="line">            <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">                DeQueue(Q, p);</span><br><span class="line">                <span class="keyword">if</span>(p) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 结点非空</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.5</p>
<p>设一棵二叉树的各个结点的结构为$(LLINK, INFO, RLINK)$，ROOT 为指向该二叉树根结点结构的指针，p 和 q 分别为指向该二叉树中任意两个结点的指针，使编写 $ANCESTOR(ROOT,\ p,\ q,\ r)$，找到 p 和 q 的最近公共祖先 r。</p>
<p>后序遍历访问根结点。</p>
<p>采用后序非递归算法，栈中存放二叉树结点的指针，当访问到某结点时，栈中所有元素均为该结点的祖先。</p>
<p>后序遍历必然先遍历到 p 和 q 中某个点，此时将栈复制到另一个辅助栈中。</p>
<p>继续遍历到另一点时，将栈中元素逐个与辅助栈中元素匹配，第一个匹配的元素就是点 p 和 q 的最近公共祖先。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    BiTree t;</span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    <span class="comment">// tag = 0 表示只访问过左子树</span></span><br><span class="line">    <span class="comment">// tag = 1 表示左右均被访问过</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">Ancestor</span><span class="params">(BiTree ROOT, BiTree *p, BiTree *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>, top1 = <span class="number">0</span>;</span><br><span class="line">    Stack S[MaxSize], S1[MaxSize]; <span class="comment">// S1 表示辅助栈</span></span><br><span class="line">    BiTree bt = ROOT;</span><br><span class="line">    <span class="keyword">int</span> tag = <span class="number">0</span>; <span class="comment">// tag 标记是否访问过第一个 即是否已经使用过辅助栈</span></span><br><span class="line">    <span class="keyword">while</span>(bt != <span class="literal">NULL</span> || top &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一直向左走</span></span><br><span class="line">        <span class="keyword">while</span>(bt != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            S[++top].t = bt;</span><br><span class="line">            S[top].tag = <span class="number">0</span>;</span><br><span class="line">            bt = bt-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(top != <span class="number">0</span> &amp;&amp; s[top].tag == <span class="number">1</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// visit 环节</span></span><br><span class="line">            <span class="keyword">if</span>(S[top].t == p || S[top].t == q)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tag == <span class="number">0</span>)&#123; <span class="comment">// 初次遇到</span></span><br><span class="line">                    tag = <span class="number">1</span>; <span class="comment">// 标记遇到第一个</span></span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt;= top;++i)&#123;</span><br><span class="line">                        S1[i] = S[i];</span><br><span class="line">                        top1 = top;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 两个都已经遇到</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">int</span> i;</span><br><span class="line">                    <span class="comment">// O(n) 遍历两个栈 找到第一个匹配的公共祖先</span></span><br><span class="line">                    <span class="keyword">for</span>(i = top; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i &lt;= top1 &amp;&amp; S1[i].t == S[i].t)</span><br><span class="line">                            <span class="keyword">return</span> S[i].t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// visit 结束</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 访问结束后弹栈</span></span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(top != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 向右下走</span></span><br><span class="line">            S[top].tag = <span class="number">1</span>;</span><br><span class="line">            bt = S[top].t-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e.6</p>
<p>写出在中序线索二叉树里查找指定结点在后序的前驱结点的算法。</p>
<p>在后序序列中：</p>
<ol>
<li>若结点 p 有右子女，则右子女是其前驱。</li>
<li>若无右子女而有左子女，则其左子女是其前驱。</li>
<li>若左右子女均无。设它在中序线索二叉树中的前驱指向某结点f。<ol>
<li>若 f 有左子女，则左子女是前驱。</li>
<li>若 f 无左子女，则继续找 f 的中序下的前驱，直到找到有左子女的结点。</li>
</ol>
</li>
<li>其他情况若 p 是中序第一个点，则 p 在中序后序下均无前驱。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BiThrTree <span class="title">InPostPre</span><span class="params">(BiThrTree t, BiThrTree p)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    BiThrTree q;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>) q = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>) q = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>) q = <span class="literal">NULL</span>; <span class="comment">// 情况4</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag == <span class="number">1</span> &amp;&amp; p-&gt;lchild != <span class="literal">NULL</span>) p = p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>) q = p-&gt;lcihld; <span class="comment">// 情况3.2</span></span><br><span class="line">        <span class="keyword">else</span> q = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><h5 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h5><p>树的存储方式有多种，可以采用顺序存储结构，也可采用链式存储结构。</p>
<p>无论何种存储结构，都要求能唯一地反映数中各结点之间的逻辑关系。</p>
<h6 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h6><p>采用一组连续的空间来存储每个结点。</p>
<p>在每个结点增设一个伪指针，指示其双亲结点在数组中的位置。</p>
<p>根结点的伪指针域为-1，结点下标为0。</p>
<p>代码描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">// n表示结点树</span></span><br><span class="line">&#125; PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>利用了每个结点（除根结点外）只有唯一双亲的性质。</p>
<p>可以很快得到每个结点的双亲信息，但求结点的孩子时需要遍历整个结构。</p>
<h6 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h6><p>每个结点的孩子结点都用单链表链接起来，形成一个线性结构。</p>
<p>寻找子女的操作非常直接，但寻找双亲的操作需要遍历整个结构。</p>
<h6 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h6><p>二叉树表示法。</p>
<p>每个指针结点包括三部分内容：</p>
<ol>
<li>结点值</li>
<li>指向结点第一个孩子结点的指针</li>
<li>指向结点下一个兄弟结点的指针</li>
</ol>
<p>代码描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种存储表示法比较灵活。可以方便地实现树转换为二叉树的操作，易于查找结点的孩子。</p>
<p>但从当前结点查找双亲结点比较麻烦。</p>
<p>但可以增设一个parent指向双亲结点，这样就会很方便。</p>
<h5 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h5><p>由于二叉树和树都可以用二叉链表作为存储结构，因此以二叉链表作为媒介可以导出树与二叉树的一个对应关系。</p>
<p>给定一棵树，可以找到唯一的一棵二叉树与之对应。</p>
<p>从物理结构上看，它们的二叉链表是相同的，只是解释不同。</p>
<p>树转二叉树：</p>
<ol>
<li>每个结点左指针指向它第一个孩子。</li>
<li>右指针指向它在树中的相邻右兄弟。</li>
</ol>
<p>由于根结点没有兄弟，所以对应的二叉树没有右子树。</p>
<p>森林转二叉树与之类似。</p>
<p>由于任何一棵和树对应的二叉树的右子树必空，若把森林中的第二棵树根视为第一棵树根的右兄弟，就可将森林转为二叉树。</p>
<p>二叉树转为树或森林是唯一的。</p>
<h5 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h5><p>树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。</p>
<ol>
<li>先根遍历。先访问根，再依次访问各个子树。与转换后的二叉树的先序遍历对应。</li>
<li>后根遍历。先访问各个子树，再访问根结点。与转换后的二叉树的中序遍历对应。</li>
</ol>
<p>森林的遍历方式。</p>
<ol>
<li>先序遍历森林。每棵树先根遍历。（先序遍历二叉树）</li>
<li>中序遍历森林。每棵树后根遍历。（中序遍历二叉树）</li>
</ol>
<h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p>一种简单的集合表示，支持三种操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Union(S, Root1, Root2); </span><br><span class="line"><span class="comment">// 把集合中的子集集合Root2并入子集集合Root1 要求Root1和Root2互不相交 否则不执行合并</span></span><br><span class="line">Find(S, X); <span class="comment">// 查找集合S中单元素X所在的自己和 并返回该子集合的名字</span></span><br><span class="line">Initatial(S); <span class="comment">// 将集合S中的每个元素都初始化为只有一个单元素的集合</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。</p>
<p>所有表示子集合的树，构成表示全集合的森林，存放在双亲表示的数组内。</p>
<p>通常用数组元素的下标代表元素名，用根结点的下标代表集合名，根结点的双亲结点为负数。</p>
<p>主要运算的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">int</span> UFSets[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x] &gt;= <span class="number">0</span>) x = S[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 要求Root1和Root2是不同的</span></span><br><span class="line">    <span class="comment">// 将根连接到另一根的下面</span></span><br><span class="line">    S[Root2] = Root1;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><h5 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h5><p>二叉排序树又称二叉查找树。</p>
<p>二叉排序树或者是一棵空树，或者满足：</p>
<ol>
<li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li>
<li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li>
<li>左右子树也分别是一棵二叉排序树。</li>
</ol>
<p>根据二叉排序树的定义，左子树结点值 &lt; 根结点值 &lt; 右子树结点值。</p>
<p>因此二叉排序树的中序遍历可以得到一个递增的有序序列。</p>
<h5 id="二叉排序树的查找"><a href="#二叉排序树的查找" class="headerlink" title="二叉排序树的查找"></a>二叉排序树的查找</h5><p>从根结点开始，沿某个分支逐层向下比较的过程。</p>
<p>若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点处的关键字，则在左子树上查找，否则在根结点的右子树上查找。</p>
<p>是一个递归的过程。</p>
<p>非递归查找算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BiTree T, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;data)&#123;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;data) T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h5><p>二叉排序树的特点是树的结构通常不是一次生成的，而是在查找的过程中，当树中不存在关键字等于值的结点时在进行插入的。</p>
<p>插入过程：若原二叉排序树为空，则直接插入结点；否则，若关键字 k 小于根结点的值，则插入到左子树，大于则插入右子树。</p>
<p>插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。</p>
<p>算法描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BiTree &amp;T, KeyType k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        T = (BiTree)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> BSTNode);</span><br><span class="line">        T-&gt;key = k;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T == T-&gt;key) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key) <span class="keyword">return</span> BST_Insert(T-&gt;lchild, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> BST_Insert(T-&gt;rchild, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h5><p>从一棵空树出发，依次输入元素，将它们插入二叉排序树中的合适的位置。</p>
<p>算法描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat_BST</span><span class="params">(BiTree &amp;T, KeyType str[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">        BST_Insert(T, str[i]);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h5><p>在树中删除一个结点时，不能把以该点为根的子树上的结点都删除，必需先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时，确保二叉排序树的性质不会丢失。</p>
<p>通常按三种情况进行处理：</p>
<ol>
<li>若被删除结点 z 是叶结点，则直接删除。</li>
<li>若结点 z 只有一棵左子树或右子树，则让 z 的子树成为 z 父结点的子树，替代 z 的位置。</li>
<li>若结点 z 有左右两棵子树，则令 z 的直接后继（或直接前驱）替代 z ，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</li>
</ol>
<p>3 是递归过程，不断向下转移直到出现 1 或 2 的情况。</p>
<h5 id="二叉排序树的查找效率分析"><a href="#二叉排序树的查找效率分析" class="headerlink" title="二叉排序树的查找效率分析"></a>二叉排序树的查找效率分析</h5><p>二叉排序树的查找效率，主要取决于树的高度。</p>
<p>若二叉排序树的左右子树的高度之差的绝对值不超过 1，则这样的二叉树称为平衡二叉树。</p>
<p>它的平均查找长度为 $O(log_2n)$。</p>
<p>若二叉排序树是只有一个左（右）孩子的单支树，则其平均查找长度为$O(n)$。</p>
<p>最坏情况，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树。</p>
<p>二分查找的判定树唯一，但二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树。</p>
<p>就维护表的有序性而言，二叉排序树无须移动结点，只需修改指针即可完成插入和删除操作。</p>
<p>平均执行时间为$O(log_2n)$。</p>
<p>当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查找操作。</p>
<p>若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构。</p>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><h5 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h5><p>为避免树的高度增长过快，降低二叉树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左右子树高度差的绝对值不超过1，将这样的而哈书称为平衡二叉树，简称平衡树。（Balanced Binary Tree）</p>
<p>定义结点左子树与右子树的高度差为该结点的平衡因子。则平衡二叉树的平衡因子只可能是 $0，-1,1$。</p>
<p>因此，平衡二叉树可以被定义为或者是一棵空树，或者是：</p>
<ol>
<li>它的左右子树都是平衡二叉树。</li>
<li>左子树和右子树的高度差的绝对值不超过1。</li>
</ol>
<p>假设 $n_h$ 表示深度为 $h$ 的平衡树中含有的最少结点数。</p>
<p>显然，有 $n_0 = 0,n_1 = 1,n_2 = 2,n_h = h_{h-1}+h_{h-2}+1$。</p>
<p>此时所有的非叶子结点的平衡因子均为1。</p>
<p>判断二叉树是否为平衡二叉树的算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Judge_AVL</span><span class="params">(BiTree bt, <span class="keyword">int</span> &amp;balance, <span class="keyword">int</span> &amp;h)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bl = <span class="number">0</span>, br = <span class="number">0</span>; <span class="comment">// 左右子树平衡标记</span></span><br><span class="line">    <span class="keyword">int</span> hl = <span class="number">0</span>, hr = <span class="number">0</span>; <span class="comment">// 左右子树高度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>) &#123; <span class="comment">// 空树 高度为0</span></span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        balance = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>)&#123; <span class="comment">// 仅有根结点 高度为1</span></span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line">        balance = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Judge_AVL(bt-&gt;lchild, bl, hl);</span><br><span class="line">    Judge_AVL(bt-&gt;rchild, br, hr);</span><br><span class="line">    h = (hl &gt; hr ? h1 : hr) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(hl - hr) &lt; <span class="number">2</span>) balance = (bl &amp;&amp; br);</span><br><span class="line">    <span class="keyword">else</span> balance = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h5><p>保证平衡的基本思想：</p>
<ol>
<li>每当插入或删除一个结点时，首先检查其插入路径上的结点是否为此次操作而导致了不平衡。</li>
<li>若导致不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点，再对以该结点为根的子树，在保持二叉排序树特性的前提下，调整各个结点的位置关系，使之重新达到平衡。</li>
</ol>
<p>每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点作为根的子树。</p>
<p>调整的规律可归纳为 4 种情况。</p>
<h6 id="LL平衡旋转（右单旋转）"><a href="#LL平衡旋转（右单旋转）" class="headerlink" title="LL平衡旋转（右单旋转）"></a>LL平衡旋转（右单旋转）</h6><p>A的左孩子的左子树（LL）上插入了新结点。</p>
<p>A的平衡因子从1增至2，导致以A为根的子树失去平衡。</p>
<p>需要一次向右的旋转操作，将A的左孩子B向右上旋转代替A成为根结点，而<strong>B的原右子树作为A结点的左子树</strong>。</p>
<p>exp:</p>
<p><img src="\images\20170429150914755-1619160414550" alt=""><br><img src="\images\20170429151109740-1619160414550" alt=""><br><img src="\images\20170429151133162-1619160414548" alt=""></p>
<h6 id="RR平衡旋转（左单旋转）"><a href="#RR平衡旋转（左单旋转）" class="headerlink" title="RR平衡旋转（左单旋转）"></a>RR平衡旋转（左单旋转）</h6><p>在结点A的右孩子的右子树（RR）上插入新结点。</p>
<p>A的平衡因子从-1减至-2，导致A为根的子树失去平衡，需要一次向左的旋转操作。</p>
<p>将A的右孩子B向左上旋转代替A称为根结点，将A结点向左下旋转称为B的左子树的根结点，<strong>B的原左子树成为A结点的右子树</strong>。</p>
<p>exp：</p>
<p><img src="\images\20170429151546105-1619160414550" alt=""><br><img src="\images\20170429151640513-1619160414550" alt=""><br><img src="\images\20170429151657665-1619160414550" alt=""></p>
<h6 id="LR平衡旋转（先左后右双旋转）"><a href="#LR平衡旋转（先左后右双旋转）" class="headerlink" title="LR平衡旋转（先左后右双旋转）"></a>LR平衡旋转（先左后右双旋转）</h6><p>在A的左子树B的右子树（LR）上插入新结点，C为B的右子树。</p>
<p><strong>先将结点C向左上旋转提升到B的位置，再将C右上旋转提升到A结点的位置。</strong></p>
<p>exp：<br><img src="\images\20170429152219778-1619160414550" alt=""><br><img src="\images\20170429152238209-1619160414550" alt=""><br><img src="\images\20170429152253788-1619160414550" alt=""></p>
<h6 id="RL平衡旋转（先右后左双旋转）"><a href="#RL平衡旋转（先右后左双旋转）" class="headerlink" title="RL平衡旋转（先右后左双旋转）"></a>RL平衡旋转（先右后左双旋转）</h6><p>在A的右孩子的左子树B（RL）上插入新结点，C为B的左子树。</p>
<p><strong>先将结点C向上旋转提升到B的位置，再将C右上旋转提升到A结点的位置。</strong></p>
<p>exp：<br><img src="\images\20170429152336570-1619160414550" alt=""><br><img src="\images\20170429152354357-1619160414550" alt=""><br><img src="\images\20170429152424982-1619160414550" alt=""></p>
<h5 id="平衡二叉树的查找"><a href="#平衡二叉树的查找" class="headerlink" title="平衡二叉树的查找"></a>平衡二叉树的查找</h5><p>进行查找的过程与二叉排序树相同。</p>
<p>在查找过程中，与给定值进行比较的关键字个数不超过树的深度。</p>
<p>含有n个结点的平衡二叉树的最大深度为$O(log_2n)$。</p>
<h4 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><h5 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h5><p>在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该结点的权。</p>
<p>从树的根到任意结点的路径长度（经过的边数）与该结点上权值的成绩，称为该结点的带权路径长度。</p>
<p>树中所有叶结点的带权路径长度之和称为该树的带权路径长度。</p>
<p>记作，<script type="math/tex">WPL = \sum_{i=1}^nw_il_i</script>。</p>
<p>式中，$w_i$是第 $i$ 个结点所带的权值，$l_i$ 是该叶结点到根结点的路径长度。</p>
<p>含有 n 个带权叶结点的二叉树中，带权路径长度最小的二叉树称为哈夫曼树，也称最优二叉树。</p>
<h5 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h5><p>给定 n 个权值分别为 $w_1,w_2,…,w_n$ 的结点，构造哈夫曼树的算法描述：</p>
<ol>
<li>将这 n 个结点分别作为 n 棵仅含一个结点的二叉树，构成森林 F。</li>
<li>构造一个新结点，从 F 中选取两棵根结点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左右子树上根结点的权值只和。</li>
<li>从 F 中删除刚才选中的两棵树，同时将得到的新树加入 F 中。</li>
<li>重复 2 和 3，直至 F 中只剩下一棵树为止。</li>
</ol>
<p>哈夫曼树的特点：</p>
<ol>
<li>每个初始结点最终都成为新结点，且权值越小的结点到根结点的路径长度越大。</li>
<li>构造过程中共新建了 $n-1$ 个结点（双分支结点），因此哈夫曼树的结点总数为 $2n-1$。</li>
<li>每次构造都选择两棵树作为新结点的孩子，因此哈夫曼树中不存在度为 1 的结点。</li>
</ol>
<h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><p>数据通信中，若对每个字符用相等长度的二进制位表示，称这种编码方式为固定长度编码。</p>
<p>若允许对不同字符用不等长的二进制为表示，则这种编码方式称为可变长度编码。</p>
<p>哈夫曼编码是一种被广泛应用而且有效的数据压缩编码。</p>
<p>若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。</p>
<p>利用哈夫曼树可以设计出总长度最短的二进制编码。</p>
<p>所有字符结点都出现在叶结点中，0 1 究竟是表示左子树还是右子树没有明确规定，左右孩子结点的顺序是任意的，所以构造出的哈夫曼树并不唯一，但可以保证各哈夫曼树的带权路径长度相同且最优。</p>
<h4 id="examples-2-2"><a href="#examples-2-2" class="headerlink" title="examples - 2"></a>examples - 2</h4><p>e.1</p>
<p>若一棵非空 k 叉树 T 中的每个非叶结点都有 k 个孩子，则称 T 为正则 k 叉树。</p>
<p>（1）若 T 有 m 个非叶结点，则 T 中的叶结点有多少个。</p>
<p>正则 k 叉树中仅含有两类结点；叶结点和度为 k 的分支结点。</p>
<p>叶结点个数为 $n_0$ 个，度为 k 的分支结点树为 $n_k$ 个。</p>
<p>树 T 中的结点总数 $n = n_0 + n_k = n_0 + m$。</p>
<p>树中所含变数为 $e = n-1$。</p>
<p>这些边均是从 m 个度为 k 的结点发出的，即 $e = mk$。</p>
<p>整理得 $n_0 +m = mk + 1$。</p>
<p>故 $n_0 = (k-1)m + 1$。</p>
<p>（2）若 T 的高度为 h （单结点的树为 h = 1），则 T 的结点数最多为多少个，最少为多少个。</p>
<p>结点最多时，树形为“满”树，第 h 层均为叶结点。</p>
<p>此时结点总数 $M_1 = \sum_{j=1}^{h}k^{j-1} = \frac{k^h - 1}{k-1}$。</p>
<p>结点最少时的树形为，第一层只有根结点，2 到 h - 1 层仅含 1 个分支结点和 k - 1 个叶结点，第 h 层有 k 个叶结点。</p>
<p>此时结点总数 $M_2 = 1 + (j-1) k$。 </p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><h5 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h5><p>图$G$是由顶点集$V$和边集$E$组成，记为$G=(V,E)$，其中$V(G)$表示图$G$中顶点的有限非空集；$E(G)$表示图$G$中顶点之间的关系（边）集合。若$V=\{v_1,v_2,…,v_n\}$，则用$|V|$表示图中顶点个数，也称图的<strong>阶</strong>。$E = \{(u,v),v\in V,v\in V\}$，用$|E|$表示图中边的条数。</p>
<p>线性表可以是空表，树可以是空树，但<strong>图不能是空图</strong>。</p>
<p>图的顶点集$V$一定非空，但边集$E$可以为空。</p>
<ol>
<li>有向图。若$E$是有向边（<strong>弧</strong>）的有限集合时，则称图为有向图。弧是顶点的有序对，记为<script type="math/tex"><v,w></script>，其中$v$称为弧尾，$w$称为弧头。顶点$v$到顶点$w$的弧，也称$v$邻接到$w$，或$w$邻接自$v$。</li>
<li>无向图。若$E$是无向边的有限集合时，则图为无向图。边是顶点的无序对，记为$(v,w)$或$(w,v)$，其中$v,w$是顶点。顶点$w$和顶点$v$互为邻接点。边$(v,w)$依附于顶点$w$和$v$，或者说边$(v,w)$和顶点$v,w$相关联。</li>
<li>简单图。一个图若满足：①不存在重复边。②不存在自身到自身的边。则称图为简单图。</li>
<li>多重图。若图中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则称图为多重图。多重图和简单图的定义是相对的。</li>
<li>完全图。对于无向图，$|E|$的取值为$n(n-1)/2$的图称为完全图。完全图中任意两个顶点之间都存在边。对于有向图，$|E|$的取值为$n(n-1)$的有向图称为有向完全图，有向完全图的任意两个顶点之间都存在方向相反的两条弧。</li>
<li>子图。两个图$G=(V,E)$和$G’=(V’,E’)$，若$V’$是$V$的子集，且$E’$是$E$的子集，则称$G’$是$G$的子图。（并非所有的子集都能构成子图，这样的子集可能不是图。）若有满足$V(G’)=V(G)$的子图$G’$，则成$G’$为$G$的生成子图。</li>
<li>连通，连通图，连通分量。若从顶点 v 到顶点 w 有路径存在，则称 v 和 w 是连通的。若途中任意两个顶点都是连通的，则称图为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量。（极大连通子图称为极大是因为此时加入任何一个不在图点集中的点都会使它不连通。）</li>
<li>强连通图，强连通分量。有向图中，若从顶点 v 到顶点 w 之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为强连通分量。（一般在无向图中讨论连通性，在有向图中讨论强连通性。）</li>
<li>生成树，生成森林。连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 n，则它的生成树含有 n-1 条边。在非连通图中，强连通分量的生成树构成了非连通图的生成森林。（包含无向图全部顶点的极小强连通子图只有生成树满足条件，因为砍去任一条边，图都不再连通。）</li>
<li>顶点的度。对于无向图，顶点 v 的度是指依附于该顶点的的边的条数，记为$TD(v)$。无向图全部顶点的度的和等于边数的2倍。对于有向图，入度是以顶点 v 为终点的有向边的数目，记为$ID(v)$，出度是以顶点 v 为起点的有向边的数目，记为$OD(v)$。顶点 v 的度等于其入度和出度之和，即$TD(v) = ID(v) + OD(v)$。</li>
<li>边的权，网。每条边都可以标上具有某种含义的数值，该数值称为该边的权值。边上带有权值的图称为带权图，也称网。</li>
<li>稠密图，稀疏图。边数很少的图称为稀疏图，反之称为稠密图。一般当图满足$|E|&lt;|V|log|V|$时，可以将其视为稀疏图。</li>
<li>路径，路径长度，回路。顶点 $v_p$ 到顶点 $v_q$ 之间的一条路径是指顶点序列 $v_p,v_{i_1},v_{i_2},…,v_{i_m},v_q$ ，关联的边可以理解为路径的构成要素，路径上边的数目称为路径长度。第一个顶点和最后一个顶点相同的路径称为回路或环。</li>
<li>简单路径，简单回路。路径序列中，顶点不重复的路径称为简单路径，同理除第一个和最后一个顶点外，其余顶点不重复存在的回路称为简单回路。</li>
<li>距离。从顶点 u 出发到顶点 v 的最短路径若存在，则此路径的长度称为从 u 到 v 的距离。若从 u 到 v 不存在路径，则记该距离为无穷。</li>
<li>有向树。一个顶点入度为 0，其余顶点入度均为 1 的有向图，称为有向树。</li>
</ol>
<h5 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h5><p>图的存储必须要完整、准确地反映顶点和边集的信息。</p>
<p>根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响。</p>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100 <span class="comment">// 顶点数目最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType; <span class="comment">// 顶点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum]; <span class="comment">// 顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];</span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum; <span class="comment">// 顶点数和弧数</span></span><br><span class="line">&#125; MGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可采用压缩存储。</li>
<li>邻接矩阵中的元素仅表示相应的边是否存在时，$EdgeType$ 可以定义为值为0和1的枚举类型。</li>
</ol>
<p>邻接矩阵的特点：</p>
<ol>
<li>有向图邻接矩阵的第 $i$ 行（列）非零元素的个数正好是第 $i$ 个顶点的出度（入度）。</li>
<li>确定两点之间是否有边很容易，要确定有多少条边的代价很大。</li>
<li>稠密图适合邻接矩阵。</li>
<li>图 $G$ 的邻接矩阵为 $A$ ，$A^n$ 的元素等于由顶点 $i$ 到顶点 $j$ 的长度为 $n$ 的路径数目。</li>
</ol>
<h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><p>对图中每个顶点建立一个单链表，表示依附于该顶点的边。</p>
<p>定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span> <span class="comment">// 边表结点</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span> <span class="comment">// 顶点表结点</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    ArcNode *first;</span><br><span class="line">&#125; VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> <span class="comment">// 邻接表</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum; <span class="comment">// 顶点数 弧数</span></span><br><span class="line">&#125; ALGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>无向图所需的存储空间为 $O(|V|+2|E|)$。有向图所需的存储空间为 $O(|V|+|E|)$。</li>
<li>稀疏图适合邻接表。</li>
<li>邻接表中，给定一个顶点，可以很快找到它的邻边。但，找到两点之间是否存在边很困难。</li>
<li>计算出度方便。</li>
<li>表示不唯一，因为个边结点的链接顺序是任意的。</li>
</ol>
<h6 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h6><p> 十字链表是有向图的一种链式存储结构。</p>
<p>十字链表中，对应于有向图中的每条弧有一个结点，对应于每一个顶点也有一个结点。</p>
<p>弧结点：<script type="math/tex"><tailvex, headvex, hlink, tlink, info></script>。有5个域，$tailvex$ （尾域）和 $headvex$ （头域），分别指示弧尾和弧头两个顶点在图中的位置。链域 $hlink$ 指向弧相同的下一条弧，链域 $tlink$ 指向弧尾相同的下一条弧。$info$ 指向该弧的相关信息。</p>
<p>顶点结点：<script type="math/tex"><data, firstin,firstout></script>。3个域，data存放相关信息，$firstin$ 和 $firstout$ 两个域分别指向以该顶点为弧头或弧尾的第一个弧结点。</p>
<p>十字链表表示法，顶点结点之间是顺序存储的。</p>
<p>图的十字链表表示是不唯一的，一个十字链表只能表示一个图。</p>
<h6 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h6><p>无向图的一种链式存储结构。</p>
<p>每条边的表示：<script type="math/tex"><mark,ivex,ilink,jvex,jlink,info></script>。mark 为标志域，标记该边是否被搜索过。$ivex$ 和 $jvex$ 为该边依附的两个顶点在图中的位置。$ilink$ 指向下一条依附于顶点 $ivex$ 的边。$jlink$ 指向下一条依附于顶点 $jvex$ 的边。info指向和边相关的各种信息。</p>
<p>每个顶点：<script type="math/tex"><data,firstedge></script>。data存储该顶点的相关信息，$firstedge$ 域指示第一条依附于该结点的边。</p>
<p>邻接多重表中，所有依附于同一顶点的边串联在同一链表中，每个边结点同时链接在两个链表中。</p>
<p>对于无向图而言，其邻接多重表和邻接表的差别仅在于同一条边在邻接表中用两个结点表示，邻接多重表中仅一个结点。</p>
<h5 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h5><p>独立于图的存储结构，抽象地考虑，忽略各变量的类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Adjacent(G, x, y); <span class="comment">// 判断图G中是否存在边&lt;x, y&gt;</span></span><br><span class="line">Neighbors(G, x); <span class="comment">// 列出图G中与结点x邻接的边</span></span><br><span class="line">InsertVertex(G, x); <span class="comment">// 在图G中插入顶点x</span></span><br><span class="line">DeleteVertex(G, x);</span><br><span class="line">AddEdge(G, x, y); <span class="comment">// 在图G中添加边&lt;x, y&gt; - 若不存在</span></span><br><span class="line">RemoveEdge(G, x, y);</span><br><span class="line">FirstNeighbor(G, x); <span class="comment">// 图G中顶点x的第一个邻接点</span></span><br><span class="line">NextNeighbor(G, x, y); <span class="comment">// 图G中顶点x的除y以外下一个邻接点</span></span><br><span class="line">Get_edge_value(G, x, y);</span><br><span class="line">Set_edge_value(G, x, y);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><p>指从图中的某一顶点出发，按照某种搜索方法沿着图中的所有顶点访问一次且仅访问一次。在访问过程中，必须记下已经访问过的节点以避免重复访问。</p>
<h5 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h5><p>一种分层查找的过程。每向前走一步可能访问一批顶点。</p>
<p>不是递归的，需要借助辅助队列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// visit(v);</span></span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    EnQueue(Q, v);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q, v);</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">for</span>(w = FirstNeighbor(G, v); w &gt;=<span class="number">0</span>; w = NextNeighbor(G, v, w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visit(w);</span><br><span class="line">                visited[w] = <span class="number">1</span>;</span><br><span class="line">                EnQueue(Q, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.vexnum;++i)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    Queue Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.vexnum;++i)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            BFS(G, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>邻接表存储的图中遍历的复杂度为 $O(|V|+|E|)$。</p>
<p>邻接矩阵的时间复杂度为 $O(|V|^2)$。</p>
<p>可以解决单源最短路径问题。（<strong>非带权图</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">int</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(Graph G, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.vexnum;++i)&#123;</span><br><span class="line">        d[i] = Infinity;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">1</span>;</span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q, u);</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">for</span>(w = FirstNeighbor(G, u); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, u, w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visited[w] = <span class="number">1</span>;</span><br><span class="line">                d[w] = d[u] + <span class="number">1</span>;</span><br><span class="line">                EnQueue(Q, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>广度优先搜索的过程，可以得到一棵遍历树，称为广度优先生成树。</p>
<p>一给定图的邻接矩阵存储表示是唯一的，因此广度优先生成树也是唯一的；而邻接表是不唯一的。</p>
<h5 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h5><p>递归形式代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>;v &lt; G.vexnum;++v)</span><br><span class="line">        visited[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>;v &lt; G.vexnum;++v)</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) DFS(G, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// visit(v);</span></span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">for</span>(w = FirstNeighbor(G, u); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, u, w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) DFS(G, w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>非递归实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_Non_RC</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w, i;</span><br><span class="line">    Stack S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.vexnum;++i)&#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Push(S, v);</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(S))&#123;</span><br><span class="line">        k = Pop(S);</span><br><span class="line">        <span class="comment">// visit(k);</span></span><br><span class="line">        <span class="keyword">for</span>(w = FirstNeighbor(G, u); w &gt;= <span class="number">0</span>; w = NextNeighbor(G, u, w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                Push(S, w);</span><br><span class="line">                visited[w] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空间复杂度为 $O(|V|)$。</p>
<p>时间复杂度性质与BFS相同。</p>
<p>DFS也可产生一棵深度优先生成树，非连通图产生深度优先生成森林。</p>
<h4 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h4><h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><p>一棵生成树包含图的所有顶点，并且只含有尽可能少的边。对于生成树来说，若砍去一条边则会使生成树变成非连通图，若添加一条边，则会形成图中的一条回路。</p>
<p>最小生成树的性质：</p>
<ol>
<li>最小生成树不是唯一的，即树形不是唯一的。当图中各边权值互不相等时，则生成树是唯一。</li>
<li>最小生成树的边权值和是唯一的，而且是最小的。</li>
<li>边数为顶点数 - 1。</li>
</ol>
<p>通用最小生成树算法：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">GENERIC_MST(G)&#123;</span><br><span class="line">	<span class="built_in">T</span> = <span class="literal">NULL</span></span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">T</span> not a MST</span><br><span class="line">		do find the <span class="built_in">min</span> (u, v) into <span class="built_in">T</span> and no circle</span><br><span class="line">			<span class="built_in">T</span> = <span class="built_in">T</span> + (u, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最关键的性质：假设 $G = (V,E)$ 是一个带权连通无向图，U 是顶点集 V 的一个非空子集。若 $(u,v)$ 是一条具有最小权值的边，其中 $u \in U, v\in V-U$，则必存在一条包含边 $(u,v)$ 的最小生成树。</p>
<h6 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h6><p>算法步骤：</p>
<ol>
<li>假设 $G = (V,E)$ 是连通图，其最小生成树 $T = (U,E_T)$，$E_T$ 是最小生成树中边的集合。</li>
<li>初始化：向空树 $T = (U,E_T)$ 中添加图 $G = (V,E)$ 的任一顶点 $u_0$，使 <script type="math/tex">U = \{u_0\},E_T = \empty</script>。</li>
<li>循环：直到 $U = V$。从图 G 中选择满足 $\{(u,v)|u\in U,v\in V-U\}$ 且具有最小权值的边 $(u,v)$ 加入树 T，置 $U = U\cup \{v\},E_T = E_T \cup \{(u,v)\}$。</li>
</ol>
<p>朴素实现的时间复杂度为 $O(|V|^2)$，不依赖于 $|E|$。适用于求解边稠密的图。</p>
<p>也可改进算法，但增加了实现的时间复杂性。</p>
<h6 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h6><p>算法步骤：</p>
<ol>
<li>假设 $G = (V,E)$ 是连通图，其最小生成树 $T = (U,E_T)$。</li>
<li>初始化：<script type="math/tex">U = V,E_T = \empty</script>。即每个顶点构成一棵独立的树，T 此时是一个仅含有 $|V|$ 个顶点的森林。</li>
<li>循环：直到 T 是一棵树。按 G 的边的权值递增顺序依次从 $E - E_T$ 中选择一条边，若加入这条边后 T 不构成回路，则将其加入 $E_T$，否则舍弃。直到 $E_T$ 中含有 n-1 条边。</li>
</ol>
<p>时间复杂度为 $O(|E|log|E|)$。</p>
<p>适合于边稀疏而顶点较多的图。</p>
<h5 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h5><h6 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h6><p>假设从 0 点出发。arcs 表示有向图的邻接矩阵。path[] 表示从源点到当前顶点之间最短路径的前驱节点。</p>
<p>算法步骤：</p>
<ol>
<li>初始化：集合 S 初始为 $\{0\}$，$dist[]$ 初始值为 $dist[i] = arcs[0][i],i = 1,2,…,n-1$。</li>
<li>从顶点集合 $V - S$ 中选出 $v_j$，满足 $dist[j] = Min\{dist[j]|v_i\in V-S\}$。令 $S = S\cup \{j\}$。</li>
<li>修改集合 $V-S$ 上任一顶点 $v_k$ 可达的最短路径长度：若 $dist[j] + arcs[j][k]&lt;dist[k]$，则修改 $dist[k]$。</li>
<li>重复操作共 n-1 次，直到所有的顶点都包含在 S 中。</li>
</ol>
<p>边上有负权，将不再使用。</p>
<p>时间复杂度为 $O(|V|^2)$。</p>
<h6 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h6><p>递推生成一个方阵序列 $A^{(-1)},A^{(0)},A^{(1)}…,A^{(n-1)}$，其中 $A^{(k)}[i][j]$ 表示顶点 $v_i$ 到 $v_j$ 的路径长度，k 表示绕行第 k 个顶点的运算步骤。</p>
<p>算法步骤：</p>
<ol>
<li>初始化：方阵 $A^{(-1)}[i][j] = arcs[i][j]$。</li>
<li>将 $v_0$ 作为中间节点，对于所有的顶点对 $\{i,j\}$，如果有 $A^{-1}[i][j] &gt; A^{-1}[i][0] + A^{-1}[0][j]$，则进行更新。得到方阵 $A^0$。</li>
<li>对其余顶点进行该操作，直到得到 $A^{(n-1)}$。</li>
</ol>
<p>时间复杂度为 $O(|V|^3)$。</p>
<p>允许有负权，但不允许有负环。</p>
<p>也使用与无向图。</p>
<h6 id="拓扑排序-AOV网"><a href="#拓扑排序-AOV网" class="headerlink" title="拓扑排序 - AOV网"></a>拓扑排序 - AOV网</h6><p>有向无环图DAG。可以用来描述表达式，比二叉树更节省空间。</p>
<p>AOV网：若用DAG图表示一个工程，其顶点表示活动，用有向边 <script type="math/tex"><V_i,V_j></script> 表示活动 $V_i$ 必需先于活动 $V_j$ 进行的这样一种关系，则将这种有向图称为定点表示活动的网络，记为AOV网。这种前驱和后继关系具有传递性，且任何活动不能以它本身作为自己的前驱或后继。</p>
<p>拓扑排序：一个有向无环图的顶点组成的序列，当且仅当满足下列条件是，称为该图的一个拓扑序</p>
<ol>
<li>每个顶点出现且进出现一次。</li>
<li>若顶点 A 在序列中排在顶点 B 的前面，则在图中不存在从顶点 B 到顶点 A 的路径。</li>
</ol>
<p>或定义为，拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点 A 到顶点 B 的路径，则在排序中顶点 B 出现在顶点 A 的后面。</p>
<p>每个AOV网都有一个或多个拓扑排序序列。</p>
<p>求AOV网的步骤：</p>
<ol>
<li>从AOV网中选择一个没有前驱的顶点并输出。</li>
<li>从网中删除该顶点和所有以它为起点的有向边。</li>
<li>重复。直到AOV网为空或不存在无前驱的点。</li>
</ol>
<p>算法实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> indegree[MAX_VERNUM];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G.vexnum; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">            Push(S, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(S))&#123;</span><br><span class="line">        Pop(S, i);</span><br><span class="line">        print[count++] = i;</span><br><span class="line">        <span class="keyword">for</span>(p = G.vertics[i].firstarc;p;p = p-&gt;nextarc)&#123;</span><br><span class="line">            v = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[v]))&#123;</span><br><span class="line">                Push(S, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; G.vexnum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>时间复杂度为 $O(|V|+|E|)$。</p>
<p>拓扑排序的结果通常不唯一。但若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前后继关系，则结果唯一。</p>
<p>如果按拓扑排序的结果重新编号，生成邻接矩阵，这种邻接矩阵可以是三角阵。三角阵一定存在拓扑序。</p>
<p>DFS 也可得到拓扑序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">int</span> time; <span class="comment">// 设置截止时间</span></span><br><span class="line"><span class="keyword">int</span> finishTime[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>;v &lt; G.vexnum;++v)&#123;</span><br><span class="line">        visited[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>;v &lt; G.vexnum;++v)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v]) DFS(G, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// visit(v);</span></span><br><span class="line">    <span class="keyword">for</span>(w = FirstNeighbor(G, v); w &gt;= <span class="number">0</span>;w = NextNeighbor(G, v, w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w]) DFS(G, w);</span><br><span class="line">    &#125;</span><br><span class="line">    time = time + <span class="number">1</span>;</span><br><span class="line">    finishTime[v] = time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将序列的结束时间按照从小到大排序即可得到拓扑序 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>逆拓扑排序：</p>
<ol>
<li>从AOV网中选择一个没有后继的顶点并输出。</li>
<li>从网中删除该顶点和所有以它为终点的有向边。</li>
<li>重复。直到当前的AOV网为空。</li>
</ol>
<h6 id="关键路径-AOE网"><a href="#关键路径-AOE网" class="headerlink" title="关键路径 - AOE网"></a>关键路径 - AOE网</h6><p>在带权有向图中，以顶点表示时间，以有向边表示活动，以边上的权值表示完成该活动的开销，称之为用边表示活动的网络，简称 AOE 网。AOE 网和 AOV 网都是有向无环图，不同之出在于他们的边和顶点所代表的含义是不同的，AOE 网中的边有权值，而 AOV 网中的边无权值，仅表示顶点之间的前后关系。</p>
<p>AOE 网的性质：</p>
<ol>
<li>只有在某顶点所表示的时间发生后，从该顶点出发的各有向边所代表的活动才能开始。</li>
<li>只有在进入某定点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。</li>
</ol>
<p>在 AOE 网中仅有一个入度为 0 的顶点，称为开始顶点（源点），它表示这个工程的开始。网中也存在一个出度为 0 的点，称为结束顶点（汇点），它表示整个工程的结束。</p>
<p>在 AOE 网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同的路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。</p>
<p>完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。</p>
<p>关键活动影响了整个工程的时间，即若关键活动不能按时完成，整个工程的完成时间就会延长。</p>
<p>几个参变量：</p>
<ol>
<li><p>事件 $v_k$ 的最早发生时间 $ve(k)$。</p>
<p>指从源点 $v_1$ 到顶点 $v_k$ 的最长路径长度。</p>
<p>计算的递推式：</p>
<ol>
<li>$ve(src) = 0$。</li>
<li>$ve(k) = Max(ve(j)+Weight(v_j,v_k))$，$v_k$ 为 $v_j$ 的任意后继。</li>
</ol>
<p>计算 $ve$ 值时，按从前往后的顺序计算，可以在拓扑排序的基础上计算：</p>
<ol>
<li>初始时，令 $ve[1…n] = 0$。</li>
<li>输出一个入度为 0 的顶点 $v_j$，计算它所有直接后继顶点 $v_k$ 的最早发生时间。$v_k = max(v_k,v_j+Weight(v_j,v_k))$。</li>
<li>直至输出所有顶点。</li>
</ol>
</li>
</ol>
<ol>
<li><p>事件 $v_k$ 的最迟发生时间 $vl(k)$。</p>
<p>指在不推迟整个工程完成的前提下，即保证它的后继事件 $v_j$ 在其最迟发生时间 $vl(j)$ 能够发生时，该事件最迟必须发生的时间。计</p>
<p>算的递推式：</p>
<ol>
<li>$vl(sink) = ve(sink)$（汇点）。</li>
<li>$vl(k) = Min(vl(j) - Weight(v_k,v_j))$，$v_k$ 为 $v_j$ 的任意前驱。</li>
</ol>
<p>可以在逆拓扑排序的基础上计算，需增设一个栈，拓扑排序结束后栈中记录逆拓扑有序序列。</p>
<p>过程如下：</p>
<ol>
<li>初始时，令 $vl[1…n] = ve[1…n]$。</li>
<li>栈顶顶点 $v_j$ 出栈，计算其所有直接前驱顶点 $v_k$ 的最迟发生时间，$vl_k=min(vlk,vl_j-Weight(v_k,v_j))$。</li>
<li>直至栈为空。</li>
</ol>
</li>
</ol>
<ol>
<li><p>活动 $a_i$ 的最早开始时间 $e(i)$。指该活动弧的起点所表示的事件的最早发生时间。若边 <script type="math/tex"><v_k,v_j></script> 表示活动 $a_i$，则有$e(i) = ve(k)$。</p>
</li>
<li><p>活动 $a_i$ 的最迟开始时间 $l(i)$。$l(i) = vl(j)-Weight(v_k,v_j)$。</p>
</li>
<li><p>一个活动 $a_i$ 的最迟开始时间 $l(i)$ 和其最早开始时间 $e(i)$ 的差额 $d(i) = l(i) - e(i)$。指该活动完成时间的余量。$d(i)=0$ 的活动是关键活动。</p>
</li>
</ol>
<p>求关键路径的算法步骤：</p>
<ol>
<li>从源点出发，令 $ve(src) = 0$，按拓扑有序求其顶点的最早发生时间 $ve()$。</li>
<li>从汇点出发，令 $vl(sink) = ve(sink)$，按逆拓扑有序求其余顶点的最迟发生时间 $vl()$。</li>
<li>根据各顶点的 $ve$ 值求所有弧的最早开始时间 $e()$。</li>
<li>根据个顶点的 $vl$ 值求所有弧的最迟开始时间 $l()$。</li>
<li>求 AOE 网中所有活动的差额 $d()$，找出所有 $d() = 0$ 的活动构成关键路径。</li>
</ol>
<p>对于关键路径，需要注意：</p>
<ol>
<li>关键路径上的所有活动都是关键活动，是决定整个工程的关键因素。</li>
<li>可以通过加快关键活动来缩短整个工程的工期。但，缩短到一定程度，关键活动可能会变化。</li>
<li>网中的关键路径不唯一，且对于几条关键路径的网，只提高一条关键路径上的关键活动不能缩短整个工期。</li>
</ol>
<h4 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h4><p>e.1</p>
<p>判断一棵无向图是否是树。</p>
<p>G 必需是无回路的连通图或有 n-1 条边的连通图。二者均可判断。</p>
<ol>
<li>无回路判断 + 连通性判断。</li>
<li>n 个顶点 n-1 条边 + 连通性判断。</li>
</ol>
<p>e.2 </p>
<p>用Dijkstra算法得到的生成树是否为最小生成树。</p>
<p>否。</p>
<p>同 Prim 相比，在添加路径时，Dijkstra 基于当前点到 $src$ 的总路径。而 Prim 仅基于这一条路径的长度。所以不一定是最小生成树。</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h4><ol>
<li>查找。数据集合中寻找满足某种条件的数据元素的过程。结果一般分为两种：查找成功和查找失败。</li>
<li>查找表，查找结构。用于查找的数据集合，由同一类型的数据元素（记录）组成，可以是一个数组或链表等数据类型。对查找表的操作一般有4种：<ol>
<li>查询某个特定的数据元素是否在查找表中。</li>
<li>检索满足条件的某个特定的数据元素的各种属性。</li>
<li>在查找表中插入一个数据元素。</li>
<li>从查找表中删除某个元素。</li>
</ol>
</li>
<li>静态查找表。无须动态修改查找表的查找表，与之对应的是动态查找表。适合静态查找表的查找方法有顺序查找、折半查找、散列查找等。适合动态查找表的查找方法有二叉排序树的查找、散列查找等。</li>
<li>关键字。数据元素中唯一表示该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</li>
<li>平均查找长度。在查找过程中，一次查找的长度是指需要比较的关键字次数。平均查找长度是所有查找过程中进行关键字的比较次数的平均值。数学定义为$ASL = \sum_{i=1}^nP_iC_i$。式中，$P_i$ 是查找第 $i$ 个数据元素的概率，一般人为每个数据元素的查找概率相等，即 $P_i = \frac{1}{n}$；$C_i$ 是找到第 $i$ 个数据元素所需要进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。</li>
</ol>
<h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><p>引入“哨兵”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> TableLen;</span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, ElemType key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>] = key; <span class="comment">// 0号位置为哨兵</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = ST.TableLen;ST.elem[i] != key;--i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>$ASL_{成功} = \frac{n+1}{2};\ \ ASL_{不成功} = n+1$。</p>
<p>顺序查找判定树：</p>
<p><img src="\images\6d55c0428c67bc04cfd2d8e7404dcf30196-1619160631553.png" alt="6d55c0428c67bc04cfd2d8e7404dcf30196.png"></p>
<h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><p>又称二分查找，仅适用于有序的顺序表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(SeqList L, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = L.TableLen - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] == key) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] &gt; key) high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>折半查找判定树：</p>
<p><img src="\images\151134_MzWS_658658-1619160631554.png" alt="img"></p>
<p>判定树是一棵平衡二叉树。</p>
<p>折半查找查找成功平均查找长度为：$ASL = log_2(n+1)-1$。</p>
<p>复杂度为 $O(log_2n)$。</p>
<h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>又称索引顺序查找。吸取了顺序查找和折半查找的各自的优点，既有动态结构，又适于快速查找。</p>
<p>基本思想：</p>
<ol>
<li>将查找表分为若干块。</li>
<li>块内可以无序，块间必需有序。每一个块中的最大关键字必需小于下一个块中的所有记录的关键字。</li>
<li>建立索引表，索引表按关键字有序排列。</li>
</ol>
<p>查找分两步，第一步在索引表中确定待查记录所在的块，可以顺序查找或折半查找。第二步是在块内顺序查找。</p>
<h4 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h4><h5 id="B树及其基本操作"><a href="#B树及其基本操作" class="headerlink" title="B树及其基本操作"></a>B树及其基本操作</h5><p>B树，又称多路平衡查找树。B树中所有结点的孩子个数的最大值称为B树的<strong>阶</strong>，通常用 m 表示。</p>
<p>一棵 m 阶B树或为空树，或为 m 叉树，特性：</p>
<ol>
<li>树中每个结点至多有 m 棵子树，即至多含有 m - 1 个关键字。</li>
<li>若根结点不是终端结点，则至少含有2棵子树。</li>
<li>除根结点外的所有非叶结点至少有 $\lceil m/2 \rceil$ 棵子树，即至少含有 $\lceil m/2 \rceil - 1$ 个关键字。</li>
<li>所有非叶结点的结构如下：$n|P_0|K_1|P_1|K_2|P_2|….|K_n|P_n$。$K_i$ 为关键字，递增。$P_i$ 为指向子树根结点的指针，指向子树中的所有结点的关键字均大于 $K_i$ 小于 $K_{i+1}$。</li>
<li>所有叶结点都出现在同一层次上，且不带任何信息。</li>
<li>所有结点的平衡因子均为 0。</li>
</ol>
<h6 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h6><p>每个结点最多有 m 棵子树，所以数中关键字的个数应该满足 $n\leq (m-1)(1+m+m^2+…+m^h)$，可以解得 $h\geq log_m(n-1)$。</p>
<p>若让每个结点中的关键字最少，则每层至少有 $\lceil m/2 \rceil$ 个关键字。同理，可得到 $h \leq log_{\lceil m/2 \rceil} ((n+1)/2)+1$</p>
<h6 id="B树的查找"><a href="#B树的查找" class="headerlink" title="B树的查找"></a>B树的查找</h6><p>类似二叉查找树，但每个结点上所做的是多路分支。</p>
<p>在结点内可以采用顺序查找法或折半查找法。</p>
<h6 id="B树的插入"><a href="#B树的插入" class="headerlink" title="B树的插入"></a>B树的插入</h6><ol>
<li>定位，查找到最底层非叶结点的查找位置。</li>
<li>插入。<ol>
<li>插入后的结点关键字个数小于 m，直接插入。</li>
<li>分裂结点。从中间位置 $\lceil m/2 \rceil$ 处将其中的关键字分成两部分。左部分包含的关键字放到原结点中，右部分放到新结点中，中间位置的结点插入到原结点的父结点中。向上传导。</li>
</ol>
</li>
</ol>
<h6 id="B树的删除"><a href="#B树的删除" class="headerlink" title="B树的删除"></a>B树的删除</h6><p>被删关键字 k 不在终端结点中时，可以用 k 的前驱或后继来代替 k，然后在终端结点中删除相关结点。</p>
<p>因此，只需讨论在终端结点中删除的情形。</p>
<ol>
<li>直接删除关键字。关键字个数 $\geq \lceil m/2 \rceil$ 时，直接删除。删除后仍满足B 树的性质。</li>
<li>兄弟够借。与结点相邻的左或右结点的关键字个数 $\ge \lceil m/2 \rceil$，删除后通过父子换位法来达到新平衡。</li>
<li>兄弟不够借。此时被删除的结点的关键字个数 $=\lceil m/2 \rceil - 1$，左或右兄弟结点的关键字个数 $=\lceil m/2 \rceil - 1$，则将关键字删除，左右结点 + 父结点中的关键字合并，此时父结点中的关键字个数 - 1。向上传导。</li>
</ol>
<h5 id="B-树的基本概念"><a href="#B-树的基本概念" class="headerlink" title="B+树的基本概念"></a>B+树的基本概念</h5><p>数据库所需的一种B树变形树。</p>
<p>m 阶B+树条件：</p>
<ol>
<li>每个分支结点最多有 m 棵子树。</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有 $\lceil m/2 \rceil $ 棵子树。</li>
<li>结点的子树个数与关键字个数相等。</li>
<li>所有叶结点包含全部关键字及其指向相应记录的指针。叶结点中将关键字排序，并且相邻的叶结点按大小顺序相互连接起来。</li>
<li>所有分支结点中仅包含它的各个子结点中关键字的最大值及指向其子结点的指针。</li>
</ol>
<p><img src="\images\image-20201218161204248-1619160631554.png" alt="image-20201218161204248"></p>
<p>B+树与B 树的区别：</p>
<ol>
<li>在B+树中，具有 n 个关键字的结点只含有 n 棵子树。而B树中有 n+1 棵。</li>
<li>B+树中，每个结点（非根内部结点）的关键字个数的范围是 $\lceil m/2\rceil \le n \le m$。（根结点可为最小1）而B 树中 $\lceil m/2\rceil - 1 \le n \le m - 1$。</li>
<li>B+树中，叶结点包含信息，所有非叶结点仅起到检索作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li>
<li>B+树中，叶结点包含了全部关键字。关键字可同时出现于叶结点和非叶结点中。B树中是不会重复的。</li>
<li>B+树中查找在非叶结点上找到时仍要向下查找。</li>
<li>B+树也可顺序查找。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">m阶B树</th>
<th style="text-align:center">m阶B+树</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类比</td>
<td style="text-align:center">二叉查找树的进化 -&gt; m 叉查找树</td>
<td style="text-align:center">分块查找的进化-&gt; 多级分块查找</td>
</tr>
<tr>
<td style="text-align:center">关键字与分叉</td>
<td style="text-align:center">n 个关键字对应 n+1 个分叉</td>
<td style="text-align:center">n 个关键字对应 n 个分叉</td>
</tr>
<tr>
<td style="text-align:center">结点包含的信息</td>
<td style="text-align:center">所有结点中都包含记录的信息</td>
<td style="text-align:center">只有最下层的叶子结点才包含记录的信息（树更矮）</td>
</tr>
<tr>
<td style="text-align:center">查找方式</td>
<td style="text-align:center">不支持顺序查找。查找成功时，可能停在任何一层结点，查找速度不稳定。</td>
<td style="text-align:center">支持顺序查找。查找成功或失败都会达到最下一层结点，查找速度稳定</td>
</tr>
</tbody>
</table>
</div>
<p>相同点：除根结点外，最少 $\lceil m/2 \rceil$ 个分叉，确保结点不要太空；任何一个结点的子树都要一样高，确保绝对平衡。</p>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><h5 id="散列表的基本概念"><a href="#散列表的基本概念" class="headerlink" title="散列表的基本概念"></a>散列表的基本概念</h5><p>线性表和树表的查找中，记录在表中的位置与记录的关键字之间不存在确定关系。因此，在这些表中查找记录时需要进行一系列的关键字比较。这类查找方法建立在“比较”的基础上，查找的效率取决于比较的次数。</p>
<p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为 $Hash(key) = Addr$。</p>
<p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这些发生碰撞的不同关键字称为同义词。一方面，设计得好的散列函数应尽量减少这样的冲突。另一方面，由于这样的冲突是不可避免的，所以还要设计好处理冲突的方法。</p>
<p>散列表：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p>
<p>理想情况下，对散列表进行查找的时间复杂度为 $O(1)$，即表中元素的个数无关。</p>
<h5 id="散列函数的构造方法"><a href="#散列函数的构造方法" class="headerlink" title="散列函数的构造方法"></a>散列函数的构造方法</h5><p>构造散列函数时，必需注意：</p>
<ol>
<li>散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li>
<li>散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。</li>
<li>散列函数应尽量简单，能够在较短时间内计算出任一关键字对应的散列地址。</li>
</ol>
<p>常用的散列函数：</p>
<ol>
<li>直接定址法。直接取关键字的某个线性函数值为散列地址，散列函数为：$H(key) = key\ ;\  H(key) = a*key+b$。</li>
<li>除留余数法。最简单，最常用的方法。假定散列表表长为 m，取一个不大于 m 但最接近或等于 m 的质数 p，利用 $H(key) = key%p$，来转换成散列地址。关键是选好 p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性。</li>
<li>数字分析法。设关键字是 r 进制数，而 r 个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等，而在某些位上分布不均匀，只有某几种数码经常出现，此时应选取数码分布比较均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了数字，则需要重新构造新的散列函数。</li>
<li>平方取中法。取关键字的平方值中间的几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，因此比较均匀。</li>
</ol>
<p>不同情况下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。目标是为了尽量讲的产生冲突的可能性。</p>
<h5 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h5><ol>
<li>开放定址法。指可存放新表项的空闲地址既向它的同义词开放，又向它的非同义词表项开放。$H_i=(H(key)+d_i)\%m$。$d_i$ 为增量序列。通常有4种取法。<ol>
<li>线性探查法。冲突发生时，顺序查看表中下一个单元（循环），直到找出一个空闲单元或查遍全表。可能会造成大量元素在相邻的散列地址上“聚集”，大大降低查找效率。</li>
<li>平方探测法。$d_i=0^2,1^2,-1^2,2^2,-2^2,…,k_2,-k^2$时，称为平方探测法。散列表长度 m 必须是一个可以表示成 4k+3 的素数，又称二次探测法。缺点是不能探测到散列表上的所有单元，但至少能够探测到一半单元。</li>
<li>再散列法。多准备几个散列函数，散列发生冲突时，用下一个散列函数计算一个新地址，直到不冲突为止。$H_i = RH_i(key)\ \ i = 1,2,3,…,k$。</li>
<li>伪随机数法。增量为伪随机数。</li>
</ol>
</li>
<li>拉链法。连接法。chaining。对于不同的关键字可能会通过散列函数映射到同一地址。为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为 $i$ 的同义词链表的头指针存放在散列表的第 $i$ 个单元中，因而查找、插入和删除操作主要在同义词链中进行。拉链法适用于经常插入和删除的情况。</li>
</ol>
<h5 id="散列查找及性能分析"><a href="#散列查找及性能分析" class="headerlink" title="散列查找及性能分析"></a>散列查找及性能分析</h5><p>虽然散列表在关键字与记录的存储位置之间建立了直接映像。但由于冲突的产生，是的散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需要以平均查找长度作为衡量散列表的查找效率的度量。</p>
<p>散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。</p>
<p>装填因子。一般记为 $\alpha$，定义为一个表的装满程度，即$\alpha = \frac{n}{m}$，n 为表中记录数，m 为散列表长度。</p>
<p>散列表的平均查找长度依赖于散列表的装填因子，而不直接依赖于 n 和 m。$\alpha$ 越大，装填记录越慢，发生冲突的可能性大。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><p>排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。</p>
<p>为了查找方便，通常希望计算机中的表是按关键字有序的。</p>
<p>确切定义：</p>
<ol>
<li>输入n个记录 $R_1,R_2,…,R_n$ ，对应的关键字为 $k_1,k_2,…,k_n$。</li>
<li>输出序列的一个重排 $R_1’,R_2’,…,R_n’$ 使得，$k_1’\leq k_2’ \leq  … \leq k_n’$，其中 $\leq$ 可以换成其他比较符号。</li>
</ol>
<p>算法的稳定性。若待排序表中有两个元素 $R_i$ 和 $R_j$，其对应的关键字相同，即 $key_1 = key_2$，且在排序前 $R_i$ 在 $R_j$ 的前面，若使用某一排序算法排序后，$R_i$ 仍在 $R_j$ 前面，则称这个排序算法是稳定的。否则就是不稳定的。</p>
<p>需要注意，算法的稳定性并不能够衡量一个算法的优劣，主要是对算法的性质进行描述。</p>
<p>如果待排序表中的关键字不允许重复，则排序结果是唯一的，选择排序算法时的稳定性就无关紧要。</p>
<p>排序过程中，根据数据元素是否完全在内存中，可将算法分为：</p>
<ol>
<li>内部排序，在排序期间全部元素存放在内存中的排序。</li>
<li>外部排序，指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断在内外存之间移动。</li>
</ol>
<p>一般情况下，内排序算法在执行过程中都要进行两种操作：比较和移动。</p>
<p>通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。</p>
<p>当然，并非所有的内排序都需要基于比较排序，例如基数排序。</p>
<p>每种排序算法有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。</p>
<p>通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类。</p>
<p>内排序算法的性能取决于算法的时间复杂度和空间复杂度，时间复杂度一般是由比较和移动的次数比较的。</p>
<p>对于任意序列进行基于比较的排序，求最少的比较次数应考虑最坏情况。对任意 n 个关键字排序的比较次数至少为 $\lceil log_2n! \rceil$。</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h5><p>对于当前元素 $L(i)$，进行的插入操作如下：</p>
<ol>
<li>查找出 $L(i)$ 在 $L[1…i-1]$ 中的插入位置 k。</li>
<li>将 $L[k…i-1]$ 中的所有元素依次后移一个位置。</li>
<li>将 $L(i)$ 复制到 $L(k)$。</li>
</ol>
<p>通常可以将 $L(2) - L(n)$ 依次插入到前面已排好序的子序列中。</p>
<p>通常采用就地排序。空间复杂度为 $O(1)$。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; A[n<span class="number">-1</span>])&#123;</span><br><span class="line">            A[<span class="number">0</span>] = A[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i - <span class="number">1</span>;A[<span class="number">0</span>] &lt; A[j]; --j)&#123;</span><br><span class="line">                A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">            &#125;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最好情况下时间复杂度$O(n)$，最坏情况下时间复杂度为$O(n^2)$。</p>
<p>是一个稳定的算法。</p>
<p>适用于顺序存储和链式存储的线性表。</p>
<h5 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h5><p>即只改进查找元素待插入位置的过程，减少比较次数。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, low, high, mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>;i &lt;= n;++i)&#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[i];</span><br><span class="line">        </span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; A[<span class="number">0</span>]) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>;j &gt;= high; --j)&#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        A[high + <span class="number">1</span>] = A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>比较次数减少的，约为 $O(nlog_2n)$。</p>
<p>而元素的移动次数并未发生改变，时间复杂度仍为 $O(n^2)$。</p>
<p>仍是一种稳定的排序算法。（upper_bound）</p>
<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><p>插入排序适合基本有序的排序表和数据量不大的排序表。</p>
<p>希尔排序又称缩小增量排序。</p>
<p>思想：</p>
<ol>
<li>先将待排序表分割成若干形如 $L[i,i+d,i+2d,…,i+kd]$ 的“特殊”子表，即把相隔某个“增量”的记录组成一个子表。</li>
<li>对各个子表进行直接插入排序。</li>
<li>当整个表中的元素已呈“基本有序”时，再对全体记录一次直接插入排序。</li>
</ol>
<p>到目前位置，尚未求得一个最好的增量序列。</p>
<p>希尔提出的方法是，$d_1 = n/2,d_{i+1} = \lfloor d_i/2 \rfloor$，且最后一个增量为1。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dk, i;</span><br><span class="line">    <span class="keyword">for</span>(dk = n / <span class="number">2</span>;dk &gt;= <span class="number">1</span>;dk = dk / <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = dk + <span class="number">1</span>;i &lt;= n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i - dk])&#123;</span><br><span class="line">                <span class="comment">// 部分直接插入排序</span></span><br><span class="line">                A[<span class="number">0</span>] = A[i];</span><br><span class="line">                <span class="keyword">for</span>(j = i - dk;j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j];j -= dk)&#123;</span><br><span class="line">                    A[j + dk] = A[j];</span><br><span class="line">                &#125;</span><br><span class="line">                A[j + dk] = A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空间效率为 $O(1)$。</p>
<p>时间复杂度分析较为困难，当 n 再某个特定范围时，希尔排序的时间复杂度约为 $O(n^{1.3})$。</p>
<p>最坏情况下，希尔排序的时间复杂度为 $O(n^2)$。</p>
<p>稳定性：可能因划分到不同的子表而改变相对顺序，因此是<strong>不稳定</strong>的算法。</p>
<p>仅适用于线性表为顺序表的情况。</p>
<h4 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h4><p>交换指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。</p>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>思想是：从后往前或从前往后两两比较相邻元素的值，若为逆序，则交换，知道序列比较完。结果是将最小的元素交换到待排序列的第一个位置或将最大的元素交换到待排序列的最后一个位置。</p>
<p>关键字最大或最小的元素如气泡一般逐渐向上“漂浮”。</p>
<p>下一趟冒泡时，前一趟确定的最小元素不再参加比较，这样最多 $n-1$ 趟冒泡就能把所有元素排好序。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, flag;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;++i)&#123;</span><br><span class="line">        flag = <span class="number">0</span>; <span class="comment">// 记录是否发生交换 没有交换直接返回</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>;j &gt; i;--j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j - <span class="number">1</span>] &gt; A[j])&#123;</span><br><span class="line">                swap(A[j - <span class="number">1</span>], A[j]);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空间复杂度为 $O(1)$。</p>
<p>时间复杂度为 $O(n^2)$，最好情况下为 $O(n)$，平均情况下为 $O(n^2)$。</p>
<p>冒泡排序也是一种稳定的排序算法。</p>
<p>双向冒泡排序。正反两个方向交替进行扫描。</p>
<p>即第一趟把最大的关键字放在最后，第二趟把最小的关键字放在最前。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(ElemType a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; flag)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = low;i &lt; high;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[i + <span class="number">1</span>])&#123;</span><br><span class="line">                swap(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high--;</span><br><span class="line">        <span class="keyword">for</span>(i = high;i &gt; low;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; a[i - <span class="number">1</span>])&#123;</span><br><span class="line">                swap(a[i], a[i - <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        low++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>基于分治算法。</p>
<ol>
<li>在待排序表 $L[1…n]$ 中任意选取一个元素 $pivot$ 作为枢轴（或基准），通常选取首元素，通过一趟排序将待排序表划分为两个独立的部分 $L[1,…,k-1]$ 和 $L[k+1,…,n]$，使得前面的元素都小于 $pivot$，后面的元素都大于等于 $pivot$。这个过程称为一趟快速排序，或一次划分。</li>
<li>分别递归地对两个子表重复该过程，知道每部分只有一个元素或为空为止。</li>
</ol>
<p><img src="\images\newQuickSort-1619160645164.gif" alt="See the source image"></p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    ElemType pivot = A[low];</span><br><span class="line">    <span class="comment">// 划分方法</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot)</span><br><span class="line">            --high;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot)</span><br><span class="line">            ++low;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = Partition(A, low, high);</span><br><span class="line">        QuickSort(A, low, pivotpos - <span class="number">1</span>);</span><br><span class="line">        QuickSort(A, pivotpos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种 随机选取枢轴值的函数方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition2</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rand_index = low + rand() % (high - low + <span class="number">1</span>);</span><br><span class="line">    swap(A[rand_index], a[low]);</span><br><span class="line">    ElemType pivot = A[low];</span><br><span class="line">    <span class="comment">// 外一种 更简便的划分方法</span></span><br><span class="line">    <span class="keyword">int</span> i = low, j;</span><br><span class="line">    <span class="keyword">for</span>(j = low + <span class="number">1</span>;j &lt;= high;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j] &lt; pivot) swap(A[++i], A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(A[i], A[low]);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空间效率：需要借助一个递归工作栈。容量与递归调用的最大深度一致。最好情况下 $O(log_2n)$，最坏情况下，因为要进行 $n-1$ 次递归调用，栈深度为 $O(n)$。平均情况下，栈深度为 $O(log_2n)$。</p>
<p>时间效率：最坏情况下为 $O(n^2)$。理想情况下复杂度为 $O(nlog_2n)$。快速排序是所有内部排序算法中平均性能最优的排序算法。</p>
<p>快速排序是一种不稳定的排序算法。</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>基本思想是，每一趟在后面所有待排序的元素中选取关键字最小的元素，作为有序子序列的第 $i$ 个元素，直到第 n - 1趟做完。</p>
<h5 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h5><p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;++i)&#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>;j &lt; n;++j)</span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[min]) min = j;</span><br><span class="line">        <span class="keyword">if</span>(min != i)swap(A[i], A[min]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表上的选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(LinkedList &amp;L)</span></span>&#123;</span><br><span class="line">    LinkNode *h = L, *p, *q, *min, *qmin;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(h != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = min = h;</span><br><span class="line">        q = qmin = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;data &gt; min-&gt;data)&#123;</span><br><span class="line">                min = p;</span><br><span class="line">                qmin = q;</span><br><span class="line">            &#125;</span><br><span class="line">            q = p;</span><br><span class="line">            p = p-&gt;link;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min == h)h = h-&gt;link;</span><br><span class="line">        <span class="keyword">else</span> qmin-&gt;link = min-&gt;link;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 头插法 得到的是从大到小排序的结果</span></span><br><span class="line">        min-&gt;link = L;</span><br><span class="line">        L = min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空间复杂度为 $O(1)$。</p>
<p>时间复杂度始终是 $O(n^2)$。</p>
<p>不是一种稳定的排序算法。</p>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><p>首先将存放在 $L[1…n]$ 中的 n 个元素建成初始堆，由于堆（大顶堆）本身的特点，堆顶元素就是最大值。</p>
<p>输出堆顶元素之后，通常将堆底元素送入堆顶，向下调整使其保证大顶堆的性质。</p>
<p>再输出堆顶元素。如此重复，直到堆中元素仅剩一个为止。</p>
<p>建立大根堆的算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将元素 k 为根的子树进行调整</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(ElemType A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k]; <span class="comment">// A[0]起到一个暂存的作用</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span> * k;i &lt;= len;i *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>]) ++i;</span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = A[i];</span><br><span class="line">            k = i; <span class="comment">// 继续向下走</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>]; <span class="comment">// 放到最终的位置上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = len / <span class="number">2</span>;i &gt; <span class="number">0</span>;--i)&#123; <span class="comment">// 从len / 2处开始调整</span></span><br><span class="line">        HeadAdjust(A, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>建堆的时间复杂度为 $O(n)$。关键字的比较总次数不超过 4n。</p>
<p>递推式为$T(n) = 2*T(n/2) + O(lg n)$</p>
<p>它的解是 T(n) = O(n)</p>
<p><img src="\images\image-20201215154124186-1619160645164.png" alt="image-20201215154124186"></p>
<p>堆排序算法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);</span><br><span class="line">    <span class="keyword">for</span>(i = len;i &gt; <span class="number">1</span>;--i)&#123;</span><br><span class="line">        swap(A[i], A[<span class="number">1</span>]);</span><br><span class="line">        HeadAdjust(A, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空间效率为 $O(1)$。</p>
<p>时间效率为 $O(nlog_2n)$。</p>
<p>算法不稳定。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并的含义是将两个或两个以上的有序表组成一个新的有序表。</p>
<p>代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ElemType *B = (ElemType *) <span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(k = low;k &lt;= high; ++k)&#123;</span><br><span class="line">        B[k] = A[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = low, j = mid + <span class="number">1</span>, k = i;i &lt;= mid &amp;&amp; j &lt;= high; ++k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i] &lt;= B[j]) A[k] = B[i++];</span><br><span class="line">        <span class="keyword">else</span> A[k] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        MergeSort(A, low, mid);</span><br><span class="line">        MergeSort(A, mid + <span class="number">1</span>, high);</span><br><span class="line">        Merge(A, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空间效率：Merge() 操作中，辅助空间刚好为 n 个单元，所以算法的空间复杂度为 $O(n)$。</p>
<p>时间复杂度为 $O(nlog_2n)$。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>不基于比较和移动进行排序，而基于关键字各位的大小进行排序。</p>
<p>是一种借助多关键字排序的思想中对单逻辑关键字进行排序的方法。</p>
<p>假设长度为 n 的线性表中每个结点 $a_j$ 的关键字有 $d$ 元组（$k_j^{d-1},k_j^{d-2},…,k_j^1,k_j^0$）组成，满足 $0 \leq k_j^i \leq r-1\ (0\leq j&lt;n,0\leq i\leq d-1)$。其中 $k_j^{d-1}$ 为最主位关键字，$k_j^0$ 为最次位关键字。</p>
<p>例如，每个关键字是 1000 以下的正整数，则基数 $r = 10$，每个关键字由 3 为子关键字构成 $K^1K^2K^3$，分别代表百位、十位和个位。</p>
<p>为实现多关键字排序，通常有两种方法：</p>
<ol>
<li>最高位优先法，按关键字位权重递减依次逐层划分成若干更小的序列，最后将所有子序列依次连接成一个有序序列。</li>
<li>最低位优先法，按关键字权重递增依次进行排序，最后形成一个有序序列。</li>
</ol>
<p>以 r 为基数的最低位优先基数排序，使用 r 个队列 $Q_0,Q_1,…,Q_{r-1}$。</p>
<p>过程：</p>
<ol>
<li>分配：开始时，把 $Q_0,Q_1,…,Q_{r-1}$ 各个队列置成空队列，然后依次考察线性表中的每个结点 $a_j(j = 0,1,…,n-1)$，若 $a_j$ 的关键字 $k_j^i = k$，就把 $a_j$ 放进 $Q_k$ 中。</li>
<li>收集：把 $Q_0,Q_1,…,Q_{r-1}$ 各个队列中的节点依次首尾相接，得到新的结点队列，从而组成新的线性表。</li>
</ol>
<p>通常采用链式基数排序。</p>
<p>空间效率：一趟排序需要的辅助存储空间为 r（r 个队头和 r 个队尾指针），但以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为 $O(r)$。</p>
<p>时间效率：一趟分配需要 $O(n)$，一趟收集需要 $O(r)$。所以时间复杂度为 $O(d(n+r))$，它与序列的初始状态无关。</p>
<p>稳定性：对于基数排序算法而言，按位排序时必须是<strong>稳定的</strong>。所以基数排序是稳定的。</p>
<h4 id="内排序的比较及应用"><a href="#内排序的比较及应用" class="headerlink" title="内排序的比较及应用"></a>内排序的比较及应用</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">算法种类</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(log_2n)$</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">2路归并排序</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(nlog_2n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">$O(d(n+r))$</td>
<td style="text-align:center">$O(d(n+r))$</td>
<td style="text-align:center">$O(d(n+r))$</td>
<td style="text-align:center">$O(r)$</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
</div>
<p>通常情况，对排序算法的比较和应用应考虑：</p>
<ol>
<li>待排序元素数目 n。</li>
<li>元素本身信息量的大小。</li>
<li>关键字的结构及其分布情况。</li>
<li>稳定性的要求。</li>
<li>语言工具的条件，存储结构及辅助空间的大小等。</li>
</ol>
<p>算法总结：</p>
<ol>
<li>若 n 较小，可采用直接插入排序或简单选择排序。记录本身信息量较大时，选用简单选择排序较好（移动次数少）。</li>
<li>若文件的初始状态已按关键字基本有序，则可以选用直接插入排序或冒泡排序。</li>
<li>若 n 较大，则应选用时间复杂度为 $O(nlog_2n)$ 的排序算法：快速排序、堆排序或归并排序。关键字随机分布时，快速排序平均时间最短。若要求稳定性，则可选用归并排序。也可改进归并为归并 + 插入以提高效率，且仍是稳定的。</li>
<li>基于比较的算法中，每次比较两个关键字的大小之后，尽可能出现两种转移，因此可以用一棵二叉树来描述比较判定过程。因此，任何借助比较的算法都至少需要 $O(nlog_2n)$ 的时间。</li>
<li>若 n 很大，记录的关键字位数少且可以分解时，采用基数排序较好。</li>
<li>记录本身信息量较大时，为避免耗费大量时间移动记录，可采用链表作为存储结构。</li>
</ol>
<h4 id="examples-1"><a href="#examples-1" class="headerlink" title="examples"></a>examples</h4><p>e.1</p>
<p>使用非递归方法实现快速排序时，通常需要一个栈记忆待排序区间的端点。能否用队列实现？</p>
<p>可以使用队列。</p>
<p>每一趟划分，可以把一个待排序区间分为两个子区间，然后分别对这两个子区间实行同样的划分。栈的作用是在处理一个子区间时，保存另一个子区间的上界和下界，待处理区间处理完后再取出下一个。队列也可实现这样的功能，只是再处理子区间时的顺序有所不同。</p>
<p>e.2</p>
<p>编写算法，能够在数组 $L[1…n]$ 中找出第 k 小的元素。</p>
<ol>
<li>先排序，在直接找第 k 小的元素，时间复杂度为 $O(nlog_2n)$。</li>
<li>采用大根堆的方法，前 k 个元素建立大根堆，扫描剩余序列，若元素值比比堆顶数值小则弹出堆顶并插入当前元素，最终堆顶记为所求。时间复杂度为 $O(k+nlog_2k)$。</li>
<li>采用小根堆的方法，每次取出最小值元素，取 k 次，时间复杂度为 $O(n +klog_2n)$。</li>
<li>基于快速排序的划分方法，选取枢轴并划分，不断递归。平均情况下可以达到 $O(n)$，最坏情况 $O(n^2)$。空间复杂度取决于划分的方法。</li>
</ol>
<p>注：枢轴思想解决问题时的平均情况下的复杂度为 $O(n)$。</p>
<p>e.3</p>
<p>三色问题，给定一个由红、白、蓝三种颜色构成的序列，在 $O(n)$ 的时间复杂度内完成对序列的重排，使序列变为“红 - 白 - 蓝”三色相连的情况。</p>
<p>设立三个指针，一个工作指针 $j$，一个指示红色 $i$，一个指示蓝色 $k$。</p>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span>RED, WHITE, BLUE&#125; color; <span class="comment">// 枚举数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Flag_Arrange</span><span class="params">(color a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= k)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(a[j])&#123;</span><br><span class="line">            <span class="keyword">case</span> RED: swap(a[i],a[j]); ++i; ++j; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WHITE: j++; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BLUE: swap(a[j], a[k]) --k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
</search>
